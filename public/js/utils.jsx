// ==========================================
// 公共工具函数
// ==========================================

const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));

async function fetchWithRetry(fn, maxRetries = 5) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (err) {
      if (i === maxRetries - 1) throw err;
      const delay = Math.pow(2, i) * 1000;
      await wait(delay);
    }
  }
}

// 纯 JS 实现的 OBJ 导出
function exportToObj(mesh) {
  if (!mesh || !mesh.geometry) return;
  const geometry = mesh.geometry;
  const positions = geometry.attributes.position.array;
  const indices = geometry.index ? geometry.index.array : null;
  let output = '# Procedural Relief Model\n# Generated by Unified 3D Workbench\no Mesh\n';
  for (let i = 0; i < positions.length; i += 3) {
    output += `v ${positions[i]} ${positions[i+1]} ${positions[i+2]}\n`;
  }
  if (indices) {
    for (let i = 0; i < indices.length; i += 3) {
      output += `f ${indices[i]+1} ${indices[i+1]+1} ${indices[i+2]+1}\n`;
    }
  } else {
    const vertexCount = positions.length / 3;
    for (let i = 0; i < vertexCount; i += 3) {
      output += `f ${i+1} ${i+2} ${i+3}\n`;
    }
  }
  return output;
}

// 3MF 多色导出（多部件分色方案）
// 策略：按颜色将 mesh 拆分为 N 个子对象，每个子对象指定不同 extruder
// 完全绕过 paint_color / TriangleSelector，避免 OrcaSlicer/BambuStudio 反序列化崩溃
async function exportTo3mf(mesh, imageBase64, numFilaments = 4) {
  if (!mesh || !mesh.geometry || !imageBase64) return;
  const geometry = mesh.geometry;
  const positions = geometry.attributes.position.array;
  const indices = geometry.index ? geometry.index.array : null;
  if (!indices) return;

  // Sample colors from the original image
  const img = new Image();
  await new Promise((resolve) => { img.onload = resolve; img.src = imageBase64; });
  const canvas = document.createElement('canvas');
  canvas.width = img.width;
  canvas.height = img.height;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(img, 0, 0);
  const imgData = ctx.getImageData(0, 0, img.width, img.height);
  const pixels = imgData.data;

  // Find mesh bounds for UV mapping (XY plane)
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  for (let i = 0; i < positions.length; i += 3) {
    minX = Math.min(minX, positions[i]);
    maxX = Math.max(maxX, positions[i]);
    minY = Math.min(minY, positions[i+1]);
    maxY = Math.max(maxY, positions[i+1]);
  }
  const rangeX = maxX - minX || 1;
  const rangeY = maxY - minY || 1;

  // Quantize color to reduce unique count (step=51 → web-safe 6 levels/channel)
  const Q = 51;
  function quantize(val) { return Math.min(255, Math.round(val / Q) * Q); }

  function sampleColor(x, y) {
    const u = Math.max(0, Math.min(1, (x - minX) / rangeX));
    const v = Math.max(0, Math.min(1, 1 - (y - minY) / rangeY));
    const px = Math.min(Math.floor(u * img.width), img.width - 1);
    const py = Math.min(Math.floor(v * img.height), img.height - 1);
    const idx = (py * img.width + px) * 4;
    return [quantize(pixels[idx]), quantize(pixels[idx+1]), quantize(pixels[idx+2])];
  }

  // Classify each triangle by color
  const colorMap = new Map();
  const triangleColors = [];

  for (let i = 0; i < indices.length; i += 3) {
    const i0 = indices[i] * 3, i1 = indices[i+1] * 3, i2 = indices[i+2] * 3;
    const cx = (positions[i0] + positions[i1] + positions[i2]) / 3;
    const cy = (positions[i0+1] + positions[i1+1] + positions[i2+1]) / 3;
    const [r, g, b] = sampleColor(cx, cy);
    const hex = `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}FF`.toUpperCase();
    if (!colorMap.has(hex)) colorMap.set(hex, colorMap.size);
    triangleColors.push(colorMap.get(hex));
  }

  let colors = Array.from(colorMap.keys());
  const parseHex = h => [parseInt(h.slice(1,3),16), parseInt(h.slice(3,5),16), parseInt(h.slice(5,7),16)];

  // Reduce to exactly numFilaments colors (AMS slot count)
  if (colors.length > numFilaments) {
    const usage = new Array(colors.length).fill(0);
    for (const ci of triangleColors) usage[ci]++;
    const ranked = usage.map((cnt, idx) => ({ idx, cnt })).sort((a, b) => b.cnt - a.cnt);
    const keepSet = new Set(ranked.slice(0, numFilaments).map(r => r.idx));
    const keepColors = Array.from(keepSet);
    const keepRgb = keepColors.map(i => parseHex(colors[i]));
    const remap = new Array(colors.length);
    const newColors = keepColors.map(i => colors[i]);
    keepColors.forEach((oldIdx, newIdx) => { remap[oldIdx] = newIdx; });
    for (let i = 0; i < colors.length; i++) {
      if (keepSet.has(i)) continue;
      const rgb = parseHex(colors[i]);
      let bestDist = Infinity, bestNew = 0;
      for (let j = 0; j < keepRgb.length; j++) {
        const d = (rgb[0]-keepRgb[j][0])**2 + (rgb[1]-keepRgb[j][1])**2 + (rgb[2]-keepRgb[j][2])**2;
        if (d < bestDist) { bestDist = d; bestNew = j; }
      }
      remap[i] = bestNew;
    }
    for (let i = 0; i < triangleColors.length; i++) triangleColors[i] = remap[triangleColors[i]];
    colors = newColors;
  }

  const nColors = colors.length;
  console.log('[exportTo3mf] Splitting mesh into', nColors, 'parts:', colors);

  // Split triangles by color group, rebuild per-part meshes with local vertex indices
  const partMeshes = [];
  for (let c = 0; c < nColors; c++) {
    const vertMap = new Map();
    const localVerts = [];
    const localTris = [];

    for (let t = 0; t < triangleColors.length; t++) {
      if (triangleColors[t] !== c) continue;
      const gi = t * 3;
      const triLocalIdx = [];
      for (let v = 0; v < 3; v++) {
        const gvi = indices[gi + v];
        if (!vertMap.has(gvi)) {
          vertMap.set(gvi, localVerts.length / 3);
          localVerts.push(positions[gvi * 3], positions[gvi * 3 + 1], positions[gvi * 3 + 2]);
        }
        triLocalIdx.push(vertMap.get(gvi));
      }
      localTris.push(triLocalIdx);
    }
    partMeshes.push({ verts: localVerts, tris: localTris });
  }

  // Production Extension format（匹配 BambuStudio Corgi 参考文件）
  // 每个颜色部件 → 独立 object_N.model 文件
  // 组装对象在 3dmodel.model 中，通过 component + p:path 引用子文件
  // p:UUID 是 Production Extension 规范必需的，BambuStudio 严格要求
  const assemblyId = nColors + 1;
  const NS = 'http://schemas.microsoft.com/3dmanufacturing/core/2015/02';
  const NS_BBS = 'http://schemas.bambulab.com/package/2021';
  const NS_P = 'http://schemas.microsoft.com/3dmanufacturing/production/2015/06';

  // 确定性 UUID 生成（基于部件索引，无需 crypto）
  function makeUUID(a, b, c, d) {
    const h = (v, len) => v.toString(16).padStart(len, '0');
    return `${h(a,8)}-${h(b,4)}-${h(c,4)}-${h(d,4)}-${h(a*256+b,12)}`;
  }

  // 为每个颜色部件生成独立的 .model 文件
  const subModelFiles = [];
  for (let c = 0; c < nColors; c++) {
    const part = partMeshes[c];
    let vXml = '';
    for (let j = 0; j < part.verts.length; j += 3) {
      vXml += `     <vertex x="${part.verts[j].toFixed(4)}" y="${part.verts[j+1].toFixed(4)}" z="${part.verts[j+2].toFixed(4)}"/>\n`;
    }
    let tXml = '';
    for (const tri of part.tris) {
      tXml += `     <triangle v1="${tri[0]}" v2="${tri[1]}" v3="${tri[2]}"/>\n`;
    }
    // 子文件 object id 必须与 config 中 part id 一致（BambuStudio 按 id 匹配，非按顺序）
    const objId = c + 1;
    const subUUID = makeUUID(objId, 1, 4001, objId);
    const xml = `<?xml version="1.0" encoding="UTF-8"?>
<model unit="millimeter" xml:lang="en-US" xmlns="${NS}" xmlns:p="${NS_P}" requiredextensions="p">
 <metadata name="BambuStudio:3mfVersion">1</metadata>
 <resources>
  <object id="${objId}" p:UUID="${subUUID}" type="model">
   <mesh>
    <vertices>
${vXml}    </vertices>
    <triangles>
${tXml}    </triangles>
   </mesh>
  </object>
 </resources>
</model>`;
    subModelFiles.push({ path: `3D/Objects/object_${c + 1}.model`, content: xml });
  }

  // 组装模型 (3dmodel.model) — component 通过 p:path 引用子文件
  const asmUUID = makeUUID(assemblyId, 2, 4002, assemblyId);
  const buildUUID = makeUUID(99, 3, 4003, 99);
  const itemUUID = makeUUID(assemblyId, 4, 4004, assemblyId);
  let componentsXml = '';
  for (let c = 0; c < nColors; c++) {
    const compUUID = makeUUID(c + 1, 5, 4005, c + 1);
    componentsXml += `    <component p:path="/3D/Objects/object_${c + 1}.model" objectid="${c + 1}" p:UUID="${compUUID}" transform="1 0 0 0 1 0 0 0 1 0 0 0"/>\n`;
  }

  const mainModel = `<?xml version="1.0" encoding="UTF-8"?>
<model unit="millimeter" xml:lang="en-US" xmlns="${NS}" xmlns:BambuStudio="${NS_BBS}" xmlns:p="${NS_P}" requiredextensions="p">
 <metadata name="Application">BambuStudio-02.04.00.70</metadata>
 <metadata name="BambuStudio:3mfVersion">1</metadata>
 <resources>
  <object id="${assemblyId}" p:UUID="${asmUUID}" type="model">
   <components>
${componentsXml}   </components>
  </object>
 </resources>
 <build p:UUID="${buildUUID}">
  <item objectid="${assemblyId}" p:UUID="${itemUUID}" transform="1 0 0 0 1 0 0 0 1 125 125 0" printable="1"/>
 </build>
</model>`;

  // model_settings.config — 每个 part 指定不同 extruder
  let partsXml = '';
  for (let c = 0; c < nColors; c++) {
    partsXml += `    <part id="${c + 1}" subtype="normal_part">
      <metadata key="name" value="Color${c + 1}"/>
      <metadata key="extruder" value="${c + 1}"/>
      <metadata key="matrix" value="1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1"/>
      <metadata key="source_file" value=""/>
      <metadata key="source_object_id" value="0"/>
      <metadata key="source_volume_id" value="0"/>
      <metadata key="source_offset_x" value="0"/>
      <metadata key="source_offset_y" value="0"/>
      <metadata key="source_offset_z" value="0"/>
      <mesh_stat edges_fixed="0" degenerate_facets="0" facets_removed="0" facets_reversed="0" backwards_edges="0"/>
    </part>\n`;
  }

  const totalTris = partMeshes.reduce((s, p) => s + p.tris.length, 0);
  const modelSettings = `<?xml version="1.0" encoding="UTF-8"?>
<config>
  <object id="${assemblyId}">
    <metadata key="name" value="ColorRelief"/>
    <metadata key="extruder" value="1"/>
    <metadata face_count="${totalTris}"/>
${partsXml}  </object>
  <plate>
    <metadata key="plater_id" value="1"/>
    <metadata key="plater_name" value=""/>
    <metadata key="locked" value="false"/>
    <metadata key="print_sequence" value="by layer"/>
    <metadata key="filament_map_mode" value="Auto For Flush"/>
    <metadata key="filament_maps" value="${Array.from({length: nColors}, (_, i) => i + 1).join(' ')}"/>
    <model_instance>
      <metadata key="object_id" value="${assemblyId}"/>
      <metadata key="instance_id" value="0"/>
      <metadata key="identify_id" value="1"/>
    </model_instance>
  </plate>
  <assemble>
   <assemble_item object_id="${assemblyId}" instance_id="0" transform="1 0 0 0 1 0 0 0 1 125 125 0" offset="0 0 0"/>
  </assemble>
</config>`;

  // 子文件关系 (3D/_rels/3dmodel.model.rels)
  let subRelsXml = '';
  for (let c = 0; c < nColors; c++) {
    subRelsXml += ` <Relationship Target="/3D/Objects/object_${c + 1}.model" Id="rel-${c + 1}" Type="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel"/>\n`;
  }
  const modelRels = `<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
${subRelsXml}</Relationships>`;

  const contentTypes = `<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
 <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
 <Default Extension="model" ContentType="application/vnd.ms-package.3dmanufacturing-3dmodel+xml"/>
</Types>`;

  const rootRels = `<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
 <Relationship Target="/3D/3dmodel.model" Id="rel-1" Type="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel"/>
</Relationships>`;

  const zip = new JSZip();
  zip.file('[Content_Types].xml', contentTypes);
  zip.folder('_rels').file('.rels', rootRels);
  zip.folder('3D').file('3dmodel.model', mainModel);
  zip.folder('3D').folder('_rels').file('3dmodel.model.rels', modelRels);
  for (const sf of subModelFiles) {
    zip.file(sf.path, sf.content);
  }
  zip.folder('Metadata').file('model_settings.config', modelSettings);

  // project_settings.config — 告诉 BambuStudio 创建 N 个 filament 槽位
  // 只包含 filament 相关字段，其余使用 slicer 默认值
  const filamentColours = colors.map(hex => `"${hex.slice(0, 7)}"`).join(',\n        ');
  const nFil = nColors;
  const rep = (v) => new Array(nFil).fill(`"${v}"`).join(',\n        ');
  const flushMatrix = [];
  for (let i = 0; i < nFil; i++) {
    for (let j = 0; j < nFil; j++) {
      flushMatrix.push(i === j ? '"0"' : '"300"');
    }
  }
  const projectSettings = `{
    "printer_settings_id": "Bambu Lab P2S 0.4 nozzle",
    "printer_model": "Bambu Lab P2S",
    "printer_variant": "0.4",
    "printer_technology": "FFF",
    "print_settings_id": "0.20mm Standard @BBL P2S",
    "nozzle_diameter": [
        "0.4"
    ],
    "printable_area": [
        "0x0", "256x0", "256x256", "0x256"
    ],
    "filament_colour": [
        ${filamentColours}
    ],
    "filament_type": [
        ${rep('PLA')}
    ],
    "filament_settings_id": [
        ${rep('Bambu PLA Basic @BBL P2S')}
    ],
    "filament_vendor": [
        ${rep('Bambu Lab')}
    ],
    "filament_ids": [
        ${rep('GFA00')}
    ],
    "filament_density": [
        ${rep('1.26')}
    ],
    "filament_diameter": [
        ${rep('1.75')}
    ],
    "filament_cost": [
        ${rep('24.99')}
    ],
    "filament_is_support": [
        ${rep('0')}
    ],
    "filament_soluble": [
        ${rep('0')}
    ],
    "default_filament_colour": [
        ${rep('')}
    ],
    "nozzle_temperature_range_low": [
        ${rep('190')}
    ],
    "nozzle_temperature_range_high": [
        ${rep('240')}
    ],
    "hot_plate_temp": [
        ${rep('55')}
    ],
    "hot_plate_temp_initial_layer": [
        ${rep('55')}
    ],
    "textured_plate_temp": [
        ${rep('55')}
    ],
    "textured_plate_temp_initial_layer": [
        ${rep('55')}
    ],
    "cool_plate_temp": [
        ${rep('35')}
    ],
    "cool_plate_temp_initial_layer": [
        ${rep('35')}
    ],
    "eng_plate_temp": [
        ${rep('55')}
    ],
    "eng_plate_temp_initial_layer": [
        ${rep('55')}
    ],
    "supertack_plate_temp": [
        ${rep('40')}
    ],
    "supertack_plate_temp_initial_layer": [
        ${rep('40')}
    ],
    "temperature_vitrification": [
        ${rep('45')}
    ],
    "filament_start_gcode": [
        ${rep('; filament start gcode\\n')}
    ],
    "filament_end_gcode": [
        ${rep('; filament end gcode \\n\\n')}
    ],
    "pressure_advance": [
        ${rep('0.02')}
    ],
    "fan_max_speed": [
        ${rep('100')}
    ],
    "fan_min_speed": [
        ${rep('100')}
    ],
    "overhang_fan_speed": [
        ${rep('100')}
    ],
    "slow_down_layer_time": [
        ${rep('4')}
    ],
    "slow_down_min_speed": [
        ${rep('20')}
    ],
    "filament_shrink": [
        ${rep('100%')}
    ],
    "flush_volumes_matrix": [
        ${flushMatrix.join(',\n        ')}
    ],
    "flush_volumes_vector": [
        ${new Array(nFil * 2).fill('"140"').join(',\n        ')}
    ]
}`;
  zip.folder('Metadata').file('project_settings.config', projectSettings);

  const blob = await zip.generateAsync({ type: 'blob', compression: 'DEFLATE' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = `relief_colored_${Date.now()}.3mf`;
  link.click();
  URL.revokeObjectURL(url);
}

// 饼干模具轮廓挤出导出 OBJ
function exportContourCutter(imageBase64, config = {}) {
  const { wallHeight = 15, wallThickness = 1.2 } = config;
  return new Promise((resolve) => {
    const img = new Image();
    img.onload = () => {
      const size = 128;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, size, size);
      const imgData = ctx.getImageData(0, 0, size, size);
      const data = imgData.data;

      // Step 1: Binarize (threshold 128)
      const binary = new Uint8Array(size * size);
      for (let i = 0; i < size * size; i++) {
        const brightness = (data[i * 4] + data[i * 4 + 1] + data[i * 4 + 2]) / 3;
        binary[i] = brightness < 128 ? 1 : 0; // 1 = black (edge), 0 = white
      }

      // Step 2: Edge detection — black pixels with at least one white neighbor
      const edges = [];
      for (let y = 1; y < size - 1; y++) {
        for (let x = 1; x < size - 1; x++) {
          if (binary[y * size + x] === 1) {
            const hasWhiteNeighbor =
              binary[(y-1)*size+x] === 0 || binary[(y+1)*size+x] === 0 ||
              binary[y*size+(x-1)] === 0 || binary[y*size+(x+1)] === 0;
            if (hasWhiteNeighbor) {
              edges.push({ x, y });
            }
          }
        }
      }

      if (edges.length === 0) { resolve(null); return; }

      // Step 3: Generate thin-wall mesh from edge points
      // Scale to physical size (60mm square)
      const scale = 60 / size;
      const halfWall = wallThickness / 2;
      let output = '# Cookie Cutter Contour Model\n# Generated by AI Workshop\no CookieCutter\n';
      let vertexCount = 0;

      // For each edge pixel, create a small wall segment
      for (const edge of edges) {
        const cx = (edge.x - size / 2) * scale;
        const cy = (size / 2 - edge.y) * scale;
        // Create a small box for each edge point (wall segment)
        const x0 = cx - halfWall, x1 = cx + halfWall;
        const y0 = cy - halfWall, y1 = cy + halfWall;
        const z0 = 0, z1 = wallHeight;

        // 8 vertices of a small box
        output += `v ${x0} ${y0} ${z0}\nv ${x1} ${y0} ${z0}\nv ${x1} ${y1} ${z0}\nv ${x0} ${y1} ${z0}\n`;
        output += `v ${x0} ${y0} ${z1}\nv ${x1} ${y0} ${z1}\nv ${x1} ${y1} ${z1}\nv ${x0} ${y1} ${z1}\n`;
        const b = vertexCount + 1;
        // 6 faces (12 triangles)
        output += `f ${b} ${b+2} ${b+1}\nf ${b} ${b+3} ${b+2}\n`; // bottom
        output += `f ${b+4} ${b+5} ${b+6}\nf ${b+4} ${b+6} ${b+7}\n`; // top
        output += `f ${b} ${b+1} ${b+5}\nf ${b} ${b+5} ${b+4}\n`; // front
        output += `f ${b+2} ${b+3} ${b+7}\nf ${b+2} ${b+7} ${b+6}\n`; // back
        output += `f ${b} ${b+4} ${b+7}\nf ${b} ${b+7} ${b+3}\n`; // left
        output += `f ${b+1} ${b+2} ${b+6}\nf ${b+1} ${b+6} ${b+5}\n`; // right
        vertexCount += 8;
      }

      const blob = new Blob([output], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `cookie_cutter_${Date.now()}.obj`;
      link.click();
      URL.revokeObjectURL(url);
      resolve(output);
    };
    img.src = imageBase64;
  });
}
