const { useState, useEffect, useRef } = React;
const {
  Box, Download, RefreshCcw, Info,
  CheckCircle2, AlertCircle, Loader2, Image: ImageIcon,
  Cpu, Wand2, RotateCcw, Sticker, Printer, Zap, Sparkles,
  Grid3X3, Hexagon, Ghost, Bot, Upload, X, FileBox, ScanEye,
  Settings2, Palette, BrainCircuit, Layers, Mountain,
  Key, Sun, Stamp, Cookie, Magnet
} = LucideReact;

// ==========================================
// part 1: 公共工具函数
// ==========================================

const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));

async function fetchWithRetry(fn, maxRetries = 5) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (err) {
      if (i === maxRetries - 1) throw err;
      const delay = Math.pow(2, i) * 1000;
      await wait(delay);
    }
  }
}

// 纯 JS 实现的 OBJ 导出
function exportToObj(mesh) {
  if (!mesh || !mesh.geometry) return;
  const geometry = mesh.geometry;
  const positions = geometry.attributes.position.array;
  const indices = geometry.index ? geometry.index.array : null;
  let output = '# Procedural Relief Model\n# Generated by Unified 3D Workbench\no Mesh\n';
  for (let i = 0; i < positions.length; i += 3) {
    output += `v ${positions[i]} ${positions[i+1]} ${positions[i+2]}\n`;
  }
  if (indices) {
    for (let i = 0; i < indices.length; i += 3) {
      output += `f ${indices[i]+1} ${indices[i+1]+1} ${indices[i+2]+1}\n`;
    }
  } else {
    const vertexCount = positions.length / 3;
    for (let i = 0; i < vertexCount; i += 3) {
      output += `f ${i+1} ${i+2} ${i+3}\n`;
    }
  }
  return output;
}

// 3MF 带颜色导出
async function exportTo3mf(mesh, imageBase64) {
  if (!mesh || !mesh.geometry || !imageBase64) return;
  const geometry = mesh.geometry;
  const positions = geometry.attributes.position.array;
  const indices = geometry.index ? geometry.index.array : null;
  if (!indices) return;

  // Sample colors from the original image
  const img = new Image();
  await new Promise((resolve) => { img.onload = resolve; img.src = imageBase64; });
  const canvas = document.createElement('canvas');
  canvas.width = img.width;
  canvas.height = img.height;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(img, 0, 0);
  const imgData = ctx.getImageData(0, 0, img.width, img.height);
  const pixels = imgData.data;

  // Find mesh bounds for UV mapping (XY plane)
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
  for (let i = 0; i < positions.length; i += 3) {
    minX = Math.min(minX, positions[i]);
    maxX = Math.max(maxX, positions[i]);
    minY = Math.min(minY, positions[i+1]);
    maxY = Math.max(maxY, positions[i+1]);
  }
  const rangeX = maxX - minX || 1;
  const rangeY = maxY - minY || 1;

  // Sample color at XY position from image
  function sampleColor(x, y) {
    const u = Math.max(0, Math.min(1, (x - minX) / rangeX));
    const v = Math.max(0, Math.min(1, 1 - (y - minY) / rangeY)); // flip Y
    const px = Math.min(Math.floor(u * img.width), img.width - 1);
    const py = Math.min(Math.floor(v * img.height), img.height - 1);
    const idx = (py * img.width + px) * 4;
    return [pixels[idx], pixels[idx+1], pixels[idx+2]];
  }

  // Collect unique colors and assign per-triangle
  const colorMap = new Map();
  const triangleColors = [];

  for (let i = 0; i < indices.length; i += 3) {
    const i0 = indices[i] * 3, i1 = indices[i+1] * 3, i2 = indices[i+2] * 3;
    // Sample at triangle centroid
    const cx = (positions[i0] + positions[i1] + positions[i2]) / 3;
    const cy = (positions[i0+1] + positions[i1+1] + positions[i2+1]) / 3;
    const [r, g, b] = sampleColor(cx, cy);
    const hex = `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`.toUpperCase();
    if (!colorMap.has(hex)) colorMap.set(hex, colorMap.size);
    triangleColors.push(colorMap.get(hex));
  }

  // Build 3MF XML
  const colors = Array.from(colorMap.keys());
  let baseMaterials = colors.map((c, i) => `        <base name="Color${i}" displaycolor="${c}" />`).join('\n');

  let vertices = '';
  for (let i = 0; i < positions.length; i += 3) {
    vertices += `          <vertex x="${positions[i].toFixed(4)}" y="${positions[i+1].toFixed(4)}" z="${positions[i+2].toFixed(4)}" />\n`;
  }

  let triangles = '';
  let triIdx = 0;
  for (let i = 0; i < indices.length; i += 3) {
    triangles += `          <triangle v1="${indices[i]}" v2="${indices[i+1]}" v3="${indices[i+2]}" pid="1" p1="${triangleColors[triIdx]}" />\n`;
    triIdx++;
  }

  const modelXml = `<?xml version="1.0" encoding="UTF-8"?>
<model unit="millimeter" xml:lang="en-US" xmlns="http://schemas.microsoft.com/3dmanufacturing/core/2015/02" xmlns:m="http://schemas.microsoft.com/3dmanufacturing/material/2015/02">
  <resources>
    <basematerials id="1">
${baseMaterials}
    </basematerials>
    <object id="2" type="model">
      <mesh>
        <vertices>
${vertices}        </vertices>
        <triangles>
${triangles}        </triangles>
      </mesh>
    </object>
  </resources>
  <build>
    <item objectid="2" />
  </build>
</model>`;

  const contentTypes = `<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" />
  <Default Extension="model" ContentType="application/vnd.ms-package.3dmanufacturing-3dmodel+xml" />
</Types>`;

  const rels = `<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Target="/3D/3dmodel.model" Id="rel0" Type="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel" />
</Relationships>`;

  const zip = new JSZip();
  zip.file('[Content_Types].xml', contentTypes);
  zip.folder('_rels').file('.rels', rels);
  zip.folder('3D').file('3dmodel.model', modelXml);

  const blob = await zip.generateAsync({ type: 'blob', compression: 'DEFLATE' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = `relief_colored_${Date.now()}.3mf`;
  link.click();
  URL.revokeObjectURL(url);
}

// ==========================================
// Part 2: AI 引擎服务 (通过后端代理)
// ==========================================

const STYLE_PRESETS = {
  standard: { id: 'standard', label: '标准 FDM', icon: React.createElement(Box, { size: 14 }), promptModifier: "designed as a children's toy model" },
  lowpoly: { id: 'lowpoly', label: '低多边形', icon: React.createElement(Hexagon, { size: 14 }), promptModifier: 'low poly style, faceted geometry' },
  voxel: { id: 'voxel', label: '体素风', icon: React.createElement(Grid3X3, { size: 14 }), promptModifier: 'voxel art style, constructed from cubes' },
  chibi: { id: 'chibi', label: 'Q版可爱', icon: React.createElement(Ghost, { size: 14 }), promptModifier: 'chibi style, super deformed proportions' },
  mecha: { id: 'mecha', label: '机甲硬核', icon: React.createElement(Bot, { size: 14 }), promptModifier: 'mecha style, industrial robotic parts' },
  organic: { id: 'organic', label: '生物有机', icon: React.createElement(Sparkles, { size: 14 }), promptModifier: 'organic style, smooth biomimetic shapes' }
};

// ==========================================
// Part 2b: 场景预设 (Scene Presets)
// ==========================================

const SCENE_PRESETS = {
  figurine: {
    id: 'figurine', label: '手办', icon: Bot,
    description: '完整立体角色，适合 Meshy AI 3D 建模',
    enabledSteps: [1, 1.5, 2, 3, 4],
    defaultExportMode: 'meshy3d',
    prompts: {
      step1: (styleModifier, subject) => `
        A concept art of a character figurine, 2D orthogonal front view, ${styleModifier}.
        Character: ${subject}.
        Requirements: Volumetric shading to show depth and form. Character MUST stand on a thick circular base.
        Compact proportions suitable for 3D FDM printing. No thin or floating parts.
        Negative Prompt: multiple views, character sheet, split screen, side view, back view, text, watermark.
      `,
      step1Trace: (styleModifier, desc) => `
        Redraw this reference image as a concept art figurine, 2D orthogonal front view.
        Target Style: ${styleModifier}.
        Subject: ${desc}.
        Requirements: Show volumetric form with shading. Character on a thick circular base. Single front view only.
      `,
      step2: () => `
        Optimize the structure for 3D printing.
        Requirements: Thicken all weak connection points (neck, ankles, arms). Ensure base connection is solid.
        Maintain the overall style and detail. Make the figure more robust for FDM printing.
      `,
      step3: (colors) => `
        Apply color to this character concept art.
        Color palette: ${colors}.
        Style: Clean flat coloring with subtle shading for volume. Clear color boundaries.
        Keep the structural details visible. Base should be dark colored.
      `
    },
    reliefConfig: null
  },
  relief: {
    id: 'relief', label: '浮雕', icon: Mountain,
    description: '经典浮雕效果，黑白线稿转 3D 浮雕',
    enabledSteps: [1, 1.5, 2, 3, 4],
    defaultExportMode: 'relief',
    prompts: {
      step1: (styleModifier, subject) => `
        A black and white line art, 2D orthogonal front view, ${styleModifier}.
        Reference Character: ${subject}.
        Core Requirements: ONLY thick black lines on white background. Lines must be clear, closed, no breaks.
        Structure Requirements: Character MUST be connected to a thick circular base at the bottom. Compact structure, avoid thin or floating parts, suitable for 3D FDM printing. Emphasize outlines and separation lines.
        Negative Prompt: multiple views, character sheet, split screen, side view, back view, gray scale, shading, gradient, text, watermark, thin lines, broken lines.
      `,
      step1Trace: (styleModifier, desc) => `
        Trace this reference image into a black and white line art, 2D orthogonal front view.
        Target Style: ${styleModifier}.
        Subject: ${desc}.
        Core Requirements: Convert all colors to thick black outlines on white background. Remove all shading and gradients.
        Structure: Ensure the character stands on a thick circular base. Check for closed loops.
        CRITICAL: Output a SINGLE VIEW only. Do not generate a character sheet.
      `,
      step2: () => `
        Optimize the structure of the previous line art.
        Core Requirements: Significantly thicken all weak connection points (neck, ankles, arm connections). Ensure the base connection is very solid. Check and close all tiny line gaps. Maintain black and white line art style.
      `,
      step3: (colors) => `
        Vector color fill of the previous line art.
        Strict Color Limit: 4 colors only (${colors}).
        Coloring Rules:
        1. Keep original thick black outlines unchanged.
        2. Fill closed areas with the specified colors.
        3. Style: Flat Design, pure solid color blocks. NO gradients, NO shadows, NO highlights, NO textures. Clear boundaries.
        4. Fill the base with Black or Dark Green for stability appearance.
      `
    },
    reliefConfig: { depth: 5, baseHeight: 3 }
  },
  keychain: {
    id: 'keychain', label: '钥匙扣', icon: Key,
    description: '小尺寸挂件，顶部带挂孔',
    enabledSteps: [1, 1.5, 2, 3, 4],
    defaultExportMode: 'meshy3d',
    prompts: {
      step1: (styleModifier, subject) => `
        A black and white line art, 2D orthogonal front view, ${styleModifier}.
        Subject: ${subject}.
        Core Requirements: ONLY thick black lines on white background. Simplified design suitable for small size (3-5cm).
        MUST have a small circular HOLE at the top for keychain ring attachment.
        Compact shape, no thin protruding parts. Thick outlines.
        Negative Prompt: multiple views, shading, gradient, text, watermark, thin lines.
      `,
      step1Trace: (styleModifier, desc) => `
        Trace this into a simplified black and white line art for a keychain.
        Style: ${styleModifier}. Subject: ${desc}.
        Simplify details for small size. Add a circular hole at top for ring attachment.
        Thick black outlines on white background only.
      `,
      step2: () => `
        Optimize for keychain production. Thicken ALL lines significantly.
        Ensure the hanging hole at top is clearly defined and circular.
        Remove any thin details that would break at small scale. Black and white only.
      `,
      step3: (colors) => `
        Color fill for keychain design. Colors: ${colors}.
        Flat solid colors only, no gradients. Bold, simple color blocks suitable for small scale viewing.
      `
    },
    reliefConfig: { depth: 1, baseHeight: 2, cutout: true }
  },
  fridgeMagnet: {
    id: 'fridgeMagnet', label: '冰箱贴', icon: Magnet || Sticker,
    description: '浅浮雕装饰片，跳过加固步骤',
    enabledSteps: [1, 1.5, 3, 4],
    defaultExportMode: 'relief',
    prompts: {
      step1: (styleModifier, subject) => `
        A black and white line art, 2D orthogonal front view, ${styleModifier}.
        Subject: ${subject}.
        Design for a decorative fridge magnet. Simple, bold outlines on white background.
        Rounded rectangular boundary. Cute, decorative style suitable for kitchen display.
        Negative Prompt: multiple views, shading, gradient, thin lines, complex details.
      `,
      step1Trace: (styleModifier, desc) => `
        Trace into a simplified decorative line art for a fridge magnet.
        Style: ${styleModifier}. Subject: ${desc}.
        Bold black outlines on white. Simple, cute design with rounded edges.
      `,
      step2: null,
      step3: (colors) => `
        Color fill for fridge magnet. Colors: ${colors}.
        Bright, cheerful flat colors. No gradients. Clear bold color blocks.
        Style suitable for a decorative kitchen magnet.
      `
    },
    reliefConfig: { depth: 1.5, baseHeight: 2, cutout: true }
  },
  lithophane: {
    id: 'lithophane', label: '透光片', icon: Sun || ScanEye,
    description: '照片转透光浮雕，暗处厚亮处薄',
    enabledSteps: [1, 1.5, 4],
    defaultExportMode: 'relief',
    prompts: {
      step1: (styleModifier, subject) => `
        A grayscale image with rich tonal gradients, ${styleModifier}.
        Subject: ${subject}.
        Requirements: Smooth grayscale transitions from pure black to pure white.
        Rich midtone detail for lithophane light transmission effect.
        No sharp edges or pure line art. Soft, photographic quality.
        Negative Prompt: color, line art, flat design, text, watermark.
      `,
      step1Trace: (styleModifier, desc) => `
        Convert this image to optimized grayscale for lithophane production.
        Subject: ${desc}. Style: ${styleModifier}.
        Create smooth tonal gradients. Enhance contrast for light transmission.
        Pure grayscale, no color.
      `,
      step2: null,
      step3: null
    },
    reliefConfig: { depth: 3, baseHeight: 0.8, inverted: true, resolution: 192 }
  },
  stamp: {
    id: 'stamp', label: '印章', icon: Stamp || FileBox,
    description: '高对比图案，自动镜像输出',
    enabledSteps: [1, 1.5, 3, 4],
    defaultExportMode: 'relief',
    prompts: {
      step1: (styleModifier, subject) => `
        A high contrast black and white silhouette or seal design, ${styleModifier}.
        Subject: ${subject}.
        Requirements: Pure black and white ONLY. No gray tones.
        Bold, thick shapes suitable for rubber stamp production.
        Clear, well-defined edges. Design should work as a stamp impression.
        Negative Prompt: gradients, shading, thin lines, gray tones, multiple views.
      `,
      step1Trace: (styleModifier, desc) => `
        Convert to a high-contrast stamp design. Subject: ${desc}. Style: ${styleModifier}.
        Pure black and white silhouette. No gray tones. Bold shapes for stamp use.
      `,
      step2: null,
      step3: (colors) => `
        This is a stamp design. Apply minimal color: ${colors}.
        Keep maximum contrast. The design must remain clearly readable as a stamp.
        Bold flat colors only.
      `
    },
    reliefConfig: { depth: 4, baseHeight: 5, mirrored: true }
  },
  cookieCutter: {
    id: 'cookieCutter', label: '饼干模具', icon: Cookie || Hexagon,
    description: '纯轮廓挤出薄壁，导出 OBJ',
    enabledSteps: [1, 1.5, 4],
    defaultExportMode: 'contour',
    prompts: {
      step1: (styleModifier, subject) => `
        A pure black outline on white background, single closed contour shape, ${styleModifier}.
        Subject: ${subject}.
        Requirements: ONLY the outer contour/silhouette outline. Single continuous closed loop.
        Thick black outline (3-5px), pure white interior and exterior.
        Simple recognizable shape suitable for cookie cutter production.
        NO internal details, NO fill, NO shading. Just the outline shape.
        Negative Prompt: internal details, shading, fill, multiple shapes, text, open curves.
      `,
      step1Trace: (styleModifier, desc) => `
        Extract only the outer contour silhouette from this image.
        Subject: ${desc}. Style: ${styleModifier}.
        Output: single thick black closed outline on white background.
        Remove ALL internal details. Only the outer shape boundary.
      `,
      step2: null,
      step3: null
    },
    reliefConfig: null,
    contourConfig: { wallHeight: 15, wallThickness: 1.2 }
  }
};

async function describeImage(base64Image) {
  const base64Data = base64Image.split(',')[1];
  const res = await fetch('/api/describe-image', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ base64Data })
  });
  if (!res.ok) throw new Error('VLM Analysis failed');
  const result = await res.json();
  if (result.error) throw new Error(result.error);
  return result.text;
}

async function translateDescription(userInput) {
  const res = await fetch('/api/translate', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ text: userInput })
  });
  if (!res.ok) throw new Error('Translation failed');
  const result = await res.json();
  if (result.error) throw new Error(result.error);
  return result.text;
}

async function generateImage(prompt, styleId, sceneId = 'relief') {
  const styleConfig = STYLE_PRESETS[styleId];
  const sceneConfig = SCENE_PRESETS[sceneId];
  const finalPrompt = sceneConfig.prompts.step1(styleConfig.promptModifier, prompt);
  const res = await fetch('/api/generate-image', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ prompt: finalPrompt })
  });
  if (!res.ok) throw new Error('Imagen failed');
  const result = await res.json();
  if (result.error) throw new Error(result.error);
  return `data:image/png;base64,${result.base64}`;
}

async function editImage(prompt, base64Image) {
  const base64Data = base64Image.split(',')[1];
  const res = await fetch('/api/edit-image', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ prompt, base64Data })
  });
  if (!res.ok) throw new Error('Edit failed');
  const result = await res.json();
  if (result.error) throw new Error(result.error);
  return `data:image/png;base64,${result.base64}`;
}

async function traceImage(referenceDesc, base64Image, styleId, sceneId = 'relief') {
  const styleConfig = STYLE_PRESETS[styleId];
  const sceneConfig = SCENE_PRESETS[sceneId];
  const prompt = sceneConfig.prompts.step1Trace(styleConfig.promptModifier, referenceDesc);
  return await editImage(prompt, base64Image);
}

async function refineStructure(base64Image, sceneId = 'relief') {
  const sceneConfig = SCENE_PRESETS[sceneId];
  if (!sceneConfig.prompts.step2) return base64Image;
  const prompt = sceneConfig.prompts.step2();
  return await editImage(prompt, base64Image);
}

async function colorFill(base64Image, customColors, sceneId = 'relief') {
  const sceneConfig = SCENE_PRESETS[sceneId];
  if (!sceneConfig.prompts.step3) return base64Image;
  const colors = customColors && customColors.length > 0 ? customColors.join(', ') : "Black, Orange, White, Green";
  const prompt = sceneConfig.prompts.step3(colors);
  return await editImage(prompt, base64Image);
}

async function analyzePrintingConfig(description, colors, styleId) {
  const res = await fetch('/api/analyze-printing', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ description, colors, styleId })
  });
  if (!res.ok) throw new Error('Analysis failed');
  const result = await res.json();
  if (result.error) throw new Error(result.error);
  return result.text;
}

async function generateMeshy3D(base64Image, modelType = 'standard') {
  const base64Data = base64Image.split(',')[1];
  const res = await fetch('/api/image-to-3d', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ base64Data, modelType })
  });
  if (!res.ok) throw new Error('3D generation failed');
  const result = await res.json();
  if (result.error) throw new Error(result.error);
  return result;
}

// 饼干模具轮廓挤出导出 OBJ
function exportContourCutter(imageBase64, config = {}) {
  const { wallHeight = 15, wallThickness = 1.2 } = config;
  return new Promise((resolve) => {
    const img = new Image();
    img.onload = () => {
      const size = 128;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, size, size);
      const imgData = ctx.getImageData(0, 0, size, size);
      const data = imgData.data;

      // Step 1: Binarize (threshold 128)
      const binary = new Uint8Array(size * size);
      for (let i = 0; i < size * size; i++) {
        const brightness = (data[i * 4] + data[i * 4 + 1] + data[i * 4 + 2]) / 3;
        binary[i] = brightness < 128 ? 1 : 0; // 1 = black (edge), 0 = white
      }

      // Step 2: Edge detection — black pixels with at least one white neighbor
      const edges = [];
      for (let y = 1; y < size - 1; y++) {
        for (let x = 1; x < size - 1; x++) {
          if (binary[y * size + x] === 1) {
            const hasWhiteNeighbor =
              binary[(y-1)*size+x] === 0 || binary[(y+1)*size+x] === 0 ||
              binary[y*size+(x-1)] === 0 || binary[y*size+(x+1)] === 0;
            if (hasWhiteNeighbor) {
              edges.push({ x, y });
            }
          }
        }
      }

      if (edges.length === 0) { resolve(null); return; }

      // Step 3: Generate thin-wall mesh from edge points
      // Scale to physical size (60mm square)
      const scale = 60 / size;
      const halfWall = wallThickness / 2;
      let output = '# Cookie Cutter Contour Model\n# Generated by AI Workshop\no CookieCutter\n';
      let vertexCount = 0;

      // For each edge pixel, create a small wall segment
      for (const edge of edges) {
        const cx = (edge.x - size / 2) * scale;
        const cy = (size / 2 - edge.y) * scale;
        // Create a small box for each edge point (wall segment)
        const x0 = cx - halfWall, x1 = cx + halfWall;
        const y0 = cy - halfWall, y1 = cy + halfWall;
        const z0 = 0, z1 = wallHeight;

        // 8 vertices of a small box
        output += `v ${x0} ${y0} ${z0}\nv ${x1} ${y0} ${z0}\nv ${x1} ${y1} ${z0}\nv ${x0} ${y1} ${z0}\n`;
        output += `v ${x0} ${y0} ${z1}\nv ${x1} ${y0} ${z1}\nv ${x1} ${y1} ${z1}\nv ${x0} ${y1} ${z1}\n`;
        const b = vertexCount + 1;
        // 6 faces (12 triangles)
        output += `f ${b} ${b+2} ${b+1}\nf ${b} ${b+3} ${b+2}\n`; // bottom
        output += `f ${b+4} ${b+5} ${b+6}\nf ${b+4} ${b+6} ${b+7}\n`; // top
        output += `f ${b} ${b+1} ${b+5}\nf ${b} ${b+5} ${b+4}\n`; // front
        output += `f ${b+2} ${b+3} ${b+7}\nf ${b+2} ${b+7} ${b+6}\n`; // back
        output += `f ${b} ${b+4} ${b+7}\nf ${b} ${b+7} ${b+3}\n`; // left
        output += `f ${b+1} ${b+2} ${b+6}\nf ${b+1} ${b+6} ${b+5}\n`; // right
        vertexCount += 8;
      }

      const blob = new Blob([output], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `cookie_cutter_${Date.now()}.obj`;
      link.click();
      URL.revokeObjectURL(url);
      resolve(output);
    };
    img.src = imageBase64;
  });
}

// ==========================================
// Part 3a: Meshy GLB 3D 预览器
// ==========================================

function MeshyScene({ glbUrl }) {
  const containerRef = useRef(null);

  useEffect(() => {
    if (!containerRef.current || !glbUrl) return;
    const w = containerRef.current.clientWidth;
    const h = containerRef.current.clientHeight;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1e293b);

    const camera = new THREE.PerspectiveCamera(45, w / h, 0.1, 1000);
    camera.position.set(0, 1.5, 3);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(w, h);
    renderer.outputEncoding = THREE.sRGBEncoding;
    containerRef.current.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.target.set(0, 0.5, 0);

    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(3, 5, 3);
    scene.add(dirLight);

    const grid = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
    scene.add(grid);

    const loader = new THREE.GLTFLoader();
    loader.load(glbUrl, (gltf) => {
      const model = gltf.scene;
      const box = new THREE.Box3().setFromObject(model);
      const center = box.getCenter(new THREE.Vector3());
      const size = box.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      const scale = 2 / maxDim;
      model.scale.setScalar(scale);
      model.position.sub(center.multiplyScalar(scale));
      model.position.y += size.y * scale / 2;
      scene.add(model);
      controls.target.set(0, size.y * scale / 2, 0);
    });

    let frameId;
    const animate = () => {
      frameId = requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    };
    animate();

    const handleResize = () => {
      if (!containerRef.current) return;
      camera.aspect = containerRef.current.clientWidth / containerRef.current.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(containerRef.current.clientWidth, containerRef.current.clientHeight);
    };
    window.addEventListener('resize', handleResize);

    return () => {
      cancelAnimationFrame(frameId);
      window.removeEventListener('resize', handleResize);
      if (containerRef.current) containerRef.current.removeChild(renderer.domElement);
      renderer.dispose();
    };
  }, [glbUrl]);

  return <div ref={containerRef} style={{ position: 'absolute', top: 0, left: 0, right: 0, bottom: 0 }} />;
}

// ==========================================
// Part 3b: 原生 Three.js 浮雕生成引擎 (Relief Engine)
// ==========================================

function ReliefScene({ imageBase64, depth = 5, baseHeight = 3, smoothing = 128, inverted = false, mirrored = false, cutout = false, cutoutThreshold = 0.92, onMeshUpdate }) {
  const containerRef = useRef(null);
  const sceneRef = useRef(null);
  const meshRef = useRef(null);
  const rendererRef = useRef(null);
  const cameraRef = useRef(null);
  const controlsRef = useRef(null);

  useEffect(() => {
    if (!containerRef.current) return;
    const container = containerRef.current;
    const w = container.clientWidth || 800;
    const h = container.clientHeight || 500;
    console.log('[ReliefScene] init renderer size:', w, h);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1e293b);

    const camera = new THREE.PerspectiveCamera(45, w/h, 0.1, 1000);
    camera.position.set(0, -50, 100);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(w, h);
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(50, 50, 100);
    dirLight.castShadow = true;
    scene.add(dirLight);

    const grid = new THREE.GridHelper(200, 20, 0x444444, 0x222222);
    grid.rotation.x = Math.PI / 2;
    scene.add(grid);

    sceneRef.current = scene;
    rendererRef.current = renderer;
    cameraRef.current = camera;
    controlsRef.current = controls;

    let frameId;
    const animate = () => {
      frameId = requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    };
    animate();

    // ResizeObserver to handle container size changes (including initial layout)
    const resizeObserver = new ResizeObserver(() => {
      if (!container) return;
      const nw = container.clientWidth;
      const nh = container.clientHeight;
      if (nw > 0 && nh > 0) {
        camera.aspect = nw / nh;
        camera.updateProjectionMatrix();
        renderer.setSize(nw, nh);
      }
    });
    resizeObserver.observe(container);

    return () => {
      cancelAnimationFrame(frameId);
      resizeObserver.disconnect();
      if (container) container.removeChild(renderer.domElement);
      renderer.dispose();
    };
  }, []);

  useEffect(() => {
    if (!imageBase64 || !sceneRef.current) return;

    const img = new Image();
    img.src = imageBase64;
    img.onload = () => {
      const canvas = document.createElement('canvas');
      const res = Math.min(smoothing, 256);
      canvas.width = res;
      canvas.height = res;
      const ctx = canvas.getContext('2d');
      // Mirrored: horizontal flip for stamp scene
      if (mirrored) {
        ctx.translate(res, 0);
        ctx.scale(-1, 1);
      }
      ctx.drawImage(img, 0, 0, res, res);
      if (mirrored) {
        ctx.setTransform(1, 0, 0, 1, 0, 0);
      }
      const imgData = ctx.getImageData(0, 0, res, res);
      const data = imgData.data;

      const size = 60;
      const segs = res - 1;
      const cellSize = size / res;
      const halfSize = size / 2;

      // Calculate brightness map
      const brightnessMap = new Float32Array(res * res);
      for (let i = 0; i < res * res; i++) {
        const pi = i * 4;
        brightnessMap[i] = pi < data.length
          ? (data[pi] * 0.299 + data[pi+1] * 0.587 + data[pi+2] * 0.114) / 255
          : 1;
      }

      // Foreground mask
      const isFg = new Uint8Array(res * res);

      if (cutout) {
        // Step 1: Box-blur the brightness map (radius=3) to close small line gaps
        const blurRadius = 3;
        const blurred = new Float32Array(res * res);
        for (let r = 0; r < res; r++) {
          for (let c = 0; c < res; c++) {
            let sum = 0, count = 0;
            for (let dr = -blurRadius; dr <= blurRadius; dr++) {
              for (let dc = -blurRadius; dc <= blurRadius; dc++) {
                const nr = r + dr, nc = c + dc;
                if (nr >= 0 && nr < res && nc >= 0 && nc < res) {
                  sum += brightnessMap[nr * res + nc];
                  count++;
                }
              }
            }
            blurred[r * res + c] = sum / count;
          }
        }

        // Step 2: Flood-fill from edges on the BLURRED map
        // Blurred lines are thicker → gaps are sealed → fill won't leak inside
        const isBackground = new Uint8Array(res * res);
        const queue = [];
        for (let r = 0; r < res; r++) {
          for (let c = 0; c < res; c++) {
            if (r === 0 || r === res - 1 || c === 0 || c === res - 1) {
              const idx = r * res + c;
              if (blurred[idx] > cutoutThreshold) {
                isBackground[idx] = 1;
                queue.push(idx);
              }
            }
          }
        }
        let head = 0;
        while (head < queue.length) {
          const idx = queue[head++];
          const r = Math.floor(idx / res);
          const c = idx % res;
          const neighbors = [];
          if (r > 0) neighbors.push((r-1)*res+c);
          if (r < res-1) neighbors.push((r+1)*res+c);
          if (c > 0) neighbors.push(r*res+(c-1));
          if (c < res-1) neighbors.push(r*res+(c+1));
          for (const ni of neighbors) {
            if (!isBackground[ni] && blurred[ni] > cutoutThreshold) {
              isBackground[ni] = 1;
              queue.push(ni);
            }
          }
        }

        // Step 3: Foreground = NOT background, then dilate 2px to recover edge lost to blur
        const rawFg = new Uint8Array(res * res);
        for (let i = 0; i < res * res; i++) rawFg[i] = isBackground[i] ? 0 : 1;

        // Dilate to compensate for blur shrinking the shape
        let currentFg = rawFg;
        for (let pass = 0; pass < 2; pass++) {
          const expanded = new Uint8Array(res * res);
          for (let r = 0; r < res; r++) {
            for (let c = 0; c < res; c++) {
              const idx = r * res + c;
              if (currentFg[idx]) { expanded[idx] = 1; continue; }
              if (r > 0 && currentFg[(r-1)*res+c]) { expanded[idx] = 1; continue; }
              if (r < res-1 && currentFg[(r+1)*res+c]) { expanded[idx] = 1; continue; }
              if (c > 0 && currentFg[r*res+(c-1)]) { expanded[idx] = 1; continue; }
              if (c < res-1 && currentFg[r*res+(c+1)]) { expanded[idx] = 1; continue; }
            }
          }
          currentFg = expanded;
        }

        for (let i = 0; i < res * res; i++) isFg[i] = currentFg[i];

        // Step 4: Hole detection — find small bright enclosed regions and punch them out
        // These are pixels that are: bright (original brightness > threshold), inside foreground,
        // and NOT reachable from the edge (so they're enclosed by the shape, like a keychain hole)
        let fgCount = 0;
        for (let i = 0; i < res * res; i++) fgCount += isFg[i];

        if (fgCount > 0) {
          // Find all bright pixels that are currently marked as foreground
          // (they were "saved" from the edge flood fill because they're enclosed)
          const visited = new Uint8Array(res * res);
          const holeMaxRatio = 0.08; // holes must be < 8% of total foreground area

          for (let r = 0; r < res; r++) {
            for (let c = 0; c < res; c++) {
              const startIdx = r * res + c;
              // Look for bright foreground pixels not yet visited
              if (visited[startIdx] || !isFg[startIdx] || brightnessMap[startIdx] <= cutoutThreshold) continue;
              // BFS to find this connected bright region within foreground
              const region = [];
              const q = [startIdx];
              visited[startIdx] = 1;
              let qHead = 0;
              while (qHead < q.length) {
                const pi = q[qHead++];
                region.push(pi);
                const pr = Math.floor(pi / res), pc = pi % res;
                const nb = [];
                if (pr > 0) nb.push((pr-1)*res+pc);
                if (pr < res-1) nb.push((pr+1)*res+pc);
                if (pc > 0) nb.push(pr*res+(pc-1));
                if (pc < res-1) nb.push(pr*res+(pc+1));
                for (const ni of nb) {
                  if (!visited[ni] && isFg[ni] && brightnessMap[ni] > cutoutThreshold) {
                    visited[ni] = 1;
                    q.push(ni);
                  }
                }
              }
              // If this enclosed bright region is small relative to foreground → it's a hole
              if (region.length > 4 && region.length < fgCount * holeMaxRatio) {
                for (const pi of region) isFg[pi] = 0;
              }
            }
          }
          // Recount
          fgCount = 0;
          for (let i = 0; i < res * res; i++) fgCount += isFg[i];
        }

        // Fallback: if foreground is empty (flood fill leaked everywhere), use plate mode
        if (fgCount === 0) isFg.fill(1);
      } else {
        isFg.fill(1);
      }

      // Build height map using foreground mask
      const heightMap = [];
      for (let i = 0; i < res * res; i++) {
        if (!isFg[i]) { heightMap.push(0); continue; }
        let b = brightnessMap[i];
        if (inverted) b = 1 - b;
        heightMap.push(baseHeight + b * depth);
      }

      // Debug: log foreground pixel count
      let fgPixels = 0;
      for (let i = 0; i < res * res; i++) fgPixels += isFg[i];
      console.log('[ReliefScene] cutout=' + cutout + ', fgPixels=' + fgPixels + '/' + (res*res) + ', baseHeight=' + baseHeight + ', depth=' + depth);

      try {

      if (cutout) {
        // === Cutout mode: per-pixel boxes for foreground only ===
        // Each foreground pixel → one box with height from heightMap
        // Background & hole pixels → no geometry at all
        const positions = [];
        const normals = [];
        const uvs = [];
        const indices = [];
        let vi = 0; // vertex index counter

        for (let r = 0; r < res; r++) {
          for (let c = 0; c < res; c++) {
            const pi = r * res + c;
            if (!isFg[pi]) continue;

            const h = heightMap[pi];
            const x0 = -halfSize + c * cellSize;
            const x1 = x0 + cellSize;
            const y0 = halfSize - r * cellSize;
            const y1 = y0 - cellSize;

            // UV from pixel position
            const u0 = c / res, u1 = (c + 1) / res;
            const v0 = r / res, v1 = (r + 1) / res;

            // Top face (z = h), normal (0,0,1)
            positions.push(x0,y0,h, x1,y0,h, x1,y1,h, x0,y1,h);
            normals.push(0,0,1, 0,0,1, 0,0,1, 0,0,1);
            uvs.push(u0,v0, u1,v0, u1,v1, u0,v1);
            indices.push(vi,vi+1,vi+2, vi,vi+2,vi+3);
            vi += 4;

            // Bottom face (z = 0), normal (0,0,-1)
            positions.push(x0,y1,0, x1,y1,0, x1,y0,0, x0,y0,0);
            normals.push(0,0,-1, 0,0,-1, 0,0,-1, 0,0,-1);
            uvs.push(u0,v1, u1,v1, u1,v0, u0,v0);
            indices.push(vi,vi+1,vi+2, vi,vi+2,vi+3);
            vi += 4;

            // Side walls — only where neighbor is background or edge
            const checkSide = (dr, dc, nx0, ny0, nx1, ny1, fnx, fny) => {
              const nr = r + dr, nc = c + dc;
              const isBg = nr < 0 || nr >= res || nc < 0 || nc >= res || !isFg[nr * res + nc];
              if (!isBg) return;
              // Wall quad from top to bottom
              positions.push(nx0,ny0,h, nx1,ny1,h, nx1,ny1,0, nx0,ny0,0);
              normals.push(fnx,fny,0, fnx,fny,0, fnx,fny,0, fnx,fny,0);
              uvs.push(0,0, 1,0, 1,1, 0,1);
              indices.push(vi,vi+1,vi+2, vi,vi+2,vi+3);
              vi += 4;
            };
            checkSide(-1, 0, x0,y0,x1,y0, 0,1);   // top neighbor → wall faces +Y
            checkSide(1, 0, x1,y1,x0,y1, 0,-1);    // bottom neighbor → wall faces -Y
            checkSide(0, -1, x0,y1,x0,y0, -1,0);   // left neighbor → wall faces -X
            checkSide(0, 1, x1,y0,x1,y1, 1,0);      // right neighbor → wall faces +X
          }
        }

        console.log('[ReliefScene] cutout mesh: ' + (vi) + ' vertices, ' + indices.length + ' indices');

        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geo.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
        geo.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
        geo.setIndex(indices);

        const texture = new THREE.Texture(img);
        texture.needsUpdate = true;
        const material = new THREE.MeshStandardMaterial({
          map: texture,
          side: THREE.DoubleSide,
          roughness: 0.4,
          metalness: 0.2,
        });

        if (meshRef.current) {
          sceneRef.current.remove(meshRef.current);
          meshRef.current.geometry.dispose();
          meshRef.current.material.dispose();
        }

        const mesh = new THREE.Mesh(geo, material);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        sceneRef.current.add(mesh);
        meshRef.current = mesh;
        if (onMeshUpdate) onMeshUpdate(mesh);

      } else {
        // === Normal plate mode (relief/lithophane/stamp) ===
        // --- Top face (relief surface) ---
        const topGeo = new THREE.PlaneGeometry(size, size, segs, segs);
        const topPos = topGeo.attributes.position;
        for (let i = 0; i < topPos.count; i++) {
          if (i < heightMap.length) topPos.setZ(i, heightMap[i]);
        }
        topGeo.computeVertexNormals();

        // --- Bottom face (flat) ---
        const bottomGeo = new THREE.PlaneGeometry(size, size, 1, 1);
        const bottomIdx = bottomGeo.index.array;
        for (let i = 0; i < bottomIdx.length; i += 3) {
          const tmp = bottomIdx[i];
          bottomIdx[i] = bottomIdx[i + 2];
          bottomIdx[i + 2] = tmp;
        }

        // --- Side walls (4 edges) ---
        const sideGeos = [];
        function createSideWall(getTopIdx, startX, startY, dirX, dirY, steps) {
          const vertices = [];
          const wallIndices = [];
          for (let i = 0; i <= steps; i++) {
            const x = startX + dirX * (i / steps) * size;
            const y = startY + dirY * (i / steps) * size;
            const topZ = heightMap[getTopIdx(i)];
            vertices.push(x, y, topZ);
            vertices.push(x, y, 0);
          }
          for (let i = 0; i < steps; i++) {
            const a = i * 2, b = i * 2 + 1, cc = (i+1) * 2, d = (i+1) * 2 + 1;
            wallIndices.push(a, b, cc, cc, b, d);
          }
          const geo = new THREE.BufferGeometry();
          geo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
          geo.setIndex(wallIndices);
          geo.computeVertexNormals();
          return geo;
        }

        sideGeos.push(createSideWall(i => i, -halfSize, -halfSize, 1, 0, segs));
        sideGeos.push(createSideWall(i => (segs) * res + (segs - i), halfSize, halfSize, -1, 0, segs));
        sideGeos.push(createSideWall(i => (segs - i) * res, -halfSize, halfSize, 0, -1, segs));
        sideGeos.push(createSideWall(i => i * res + segs, halfSize, -halfSize, 0, 1, segs));

        // Merge all geometries
        const allGeos = [topGeo, bottomGeo, ...sideGeos];
        let totalVerts = 0;
        allGeos.forEach(g => { totalVerts += g.attributes.position.count; });

        const mergedPositions = new Float32Array(totalVerts * 3);
        const mergedNormals = new Float32Array(totalVerts * 3);
        const mergedIndices = [];
        let vertOffset = 0;

        allGeos.forEach(g => {
          const pos = g.attributes.position.array;
          const nor = g.attributes.normal ? g.attributes.normal.array : new Float32Array(pos.length);
          mergedPositions.set(pos, vertOffset * 3);
          mergedNormals.set(nor, vertOffset * 3);
          if (g.index) {
            for (let i = 0; i < g.index.count; i++) {
              mergedIndices.push(g.index.array[i] + vertOffset);
            }
          }
          vertOffset += g.attributes.position.count;
        });

        const mergedGeo = new THREE.BufferGeometry();
        mergedGeo.setAttribute('position', new THREE.BufferAttribute(mergedPositions, 3));
        mergedGeo.setAttribute('normal', new THREE.BufferAttribute(mergedNormals, 3));
        mergedGeo.setIndex(mergedIndices);

        const texture = new THREE.Texture(img);
        texture.needsUpdate = true;
        const material = new THREE.MeshStandardMaterial({
          map: texture,
          side: THREE.DoubleSide,
          roughness: 0.4,
          metalness: 0.2,
        });

        if (meshRef.current) {
          sceneRef.current.remove(meshRef.current);
          meshRef.current.geometry.dispose();
          meshRef.current.material.dispose();
        }

        const mesh = new THREE.Mesh(mergedGeo, material);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        sceneRef.current.add(mesh);
        meshRef.current = mesh;
        if (onMeshUpdate) onMeshUpdate(mesh);
      }

      // Auto-center camera on mesh bounding box
      if (meshRef.current && controlsRef.current && cameraRef.current) {
        const box = new THREE.Box3().setFromObject(meshRef.current);
        const center = box.getCenter(new THREE.Vector3());
        const bSize = box.getSize(new THREE.Vector3());
        const maxDim = Math.max(bSize.x, bSize.y, bSize.z);
        controlsRef.current.target.copy(center);
        cameraRef.current.position.set(center.x, center.y - maxDim * 0.6, center.z + maxDim * 1.2);
        controlsRef.current.update();
      }

      } catch (err) {
        console.error('[ReliefScene] geometry error:', err);
      }
    };
  }, [imageBase64, depth, baseHeight, smoothing, inverted, mirrored, cutout, cutoutThreshold]);

  return <div ref={containerRef} style={{ position: 'absolute', top: 0, left: 0, right: 0, bottom: 0 }} />;
}

// ==========================================
// Part 4: UI 组件
// ==========================================

function StepControl({ active, completed, title, icon, children }) {
  return (
    <div className={`p-5 rounded-[2rem] border transition-all duration-300 ${active ? 'bg-white border-blue-200 shadow-xl scale-[1.01]' : 'bg-white/60 border-slate-100 opacity-80'}`}>
      <div className="flex items-center gap-3 mb-4">
        <div className={`flex items-center justify-center w-8 h-8 rounded-full font-bold text-sm ${active ? 'bg-blue-600 text-white' : 'bg-slate-200 text-slate-500'}`}>
          {completed ? <CheckCircle2 size={16}/> : (active ? <Zap size={16}/> : <Box size={16}/>)}
        </div>
        <div className="flex-1 font-bold text-slate-800 text-sm">{title}</div>
      </div>
      {active && <div className="animate-in fade-in slide-in-from-top-2">{children}</div>}
    </div>
  );
}

function Slider({ label, value, min, max, step=1, onChange }) {
  return (
    <div className="space-y-1">
      <div className="flex justify-between text-[10px] text-slate-400"><span>{label}</span><span className="font-mono text-blue-400">{value}</span></div>
      <input type="range" min={min} max={max} step={step} value={value} onChange={e=>onChange(parseFloat(e.target.value))} className="w-full h-1 bg-slate-800 rounded-lg appearance-none cursor-pointer accent-indigo-500" />
    </div>
  );
}

// ==========================================
// Part 5: 主程序
// ==========================================

function AiWorkshop() {
  const [currentStep, setCurrentStep] = useState(1);
  const [loading, setLoading] = useState(false);
  const [loadingMsg, setLoadingMsg] = useState("");
  const [error, setError] = useState(null);
  const [analyzing, setAnalyzing] = useState(false);
  const [printAdvice, setPrintAdvice] = useState(null);
  const [modifyPrompt, setModifyPrompt] = useState("");
  const [sceneId, setSceneId] = useState('relief');
  const [step4Mode, setStep4Mode] = useState('relief'); // 'relief', 'meshy3d', or 'contour'
  const [meshy3dResult, setMeshy3dResult] = useState(null);
  const [contourConfig, setContourConfig] = useState({ wallHeight: 15, wallThickness: 1.2 });
  const [workflowData, setWorkflowData] = useState({
    description: "一只戴着宇航头盔的小猫，正坐姿态",
    style: 'standard', uploadedReference: null,
    step1Image: null, step2Image: null, step3Image: null,
    colors: ['#000000', '#FF8C00', '#FFFFFF', '#228B22'],
    reliefDepth: 5, reliefBaseHeight: 3, reliefResolution: 128
  });
  const fileInputRef = useRef(null);
  const meshToExport = useRef(null);

  // Scene helpers
  const currentScene = SCENE_PRESETS[sceneId];
  const isStepEnabled = (step) => currentScene.enabledSteps.includes(step);

  const handleSceneChange = (newSceneId) => {
    const scene = SCENE_PRESETS[newSceneId];
    setSceneId(newSceneId);
    setCurrentStep(1);
    setError(null);
    setMeshy3dResult(null);
    setPrintAdvice(null);
    setModifyPrompt("");
    // Set default export mode
    setStep4Mode(scene.defaultExportMode === 'meshy3d' ? 'meshy3d' : scene.defaultExportMode === 'contour' ? 'contour' : 'relief');
    // Apply scene-specific relief defaults
    if (scene.reliefConfig) {
      setWorkflowData(prev => ({
        ...prev,
        step1Image: null, step2Image: null, step3Image: null,
        reliefDepth: scene.reliefConfig.depth ?? prev.reliefDepth,
        reliefBaseHeight: scene.reliefConfig.baseHeight ?? prev.reliefBaseHeight,
        reliefResolution: scene.reliefConfig.resolution ?? 128,
      }));
    } else {
      setWorkflowData(prev => ({ ...prev, step1Image: null, step2Image: null, step3Image: null }));
    }
    if (scene.contourConfig) {
      setContourConfig(scene.contourConfig);
    }
  };

  // Go to the next enabled step after `current`
  const goToNextStep = (current) => {
    const stepOrder = [1, 1.5, 2, 3, 4];
    const currentIdx = stepOrder.indexOf(current);
    for (let i = currentIdx + 1; i < stepOrder.length; i++) {
      if (isStepEnabled(stepOrder[i])) {
        // For steps that get skipped, pass images through
        const nextStep = stepOrder[i];
        if (nextStep === 2 && !isStepEnabled(2)) continue;
        if (nextStep === 3 && !isStepEnabled(3)) continue;
        if (nextStep === 4) {
          // Before going to step 4, ensure images are passed through skipped steps
          setWorkflowData(prev => {
            const updated = { ...prev };
            if (!isStepEnabled(2) && !updated.step2Image) updated.step2Image = updated.step1Image;
            if (!isStepEnabled(3) && !updated.step3Image) updated.step3Image = updated.step2Image || updated.step1Image;
            return updated;
          });
        }
        setCurrentStep(nextStep >= 2 ? Math.ceil(nextStep) : nextStep);
        return;
      }
    }
    // If no more enabled steps, just go to 4
    setWorkflowData(prev => {
      const updated = { ...prev };
      if (!updated.step2Image) updated.step2Image = updated.step1Image;
      if (!updated.step3Image) updated.step3Image = updated.step2Image || updated.step1Image;
      return updated;
    });
    setCurrentStep(4);
  };

  const handleImageUpload = (e) => {
    const file = e.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (ev) => setWorkflowData(prev => ({ ...prev, uploadedReference: ev.target.result, step1Image: null }));
      reader.readAsDataURL(file);
    }
  };

  // Step 1: 生成图片
  const handleStep1 = async () => {
    setLoading(true); setError(null);
    try {
      let subjectDesc = workflowData.description;
      if (workflowData.uploadedReference) {
        setLoadingMsg("VLM 视觉分析...");
        subjectDesc = await fetchWithRetry(() => describeImage(workflowData.uploadedReference));
        setWorkflowData(prev => ({ ...prev, description: subjectDesc }));

        setLoadingMsg("参考图重绘...");
        const img = await fetchWithRetry(() => traceImage(subjectDesc, workflowData.uploadedReference, workflowData.style, sceneId));
        setWorkflowData(prev => ({ ...prev, step1Image: img }));
      } else {
        setLoadingMsg("翻译提示词...");
        const translatedPrompt = await fetchWithRetry(() => translateDescription(subjectDesc));
        setLoadingMsg("生成图片...");
        const img = await fetchWithRetry(() => generateImage(translatedPrompt, workflowData.style, sceneId));
        setWorkflowData(prev => ({ ...prev, step1Image: img }));
      }
    } catch (e) { setError("生成失败: " + e.message); }
    finally { setLoading(false); }
  };

  // Step 1.5: 修改线稿
  const handleModifyImage = async () => {
    if (!modifyPrompt.trim() || !workflowData.step1Image) return;
    setLoading(true); setError(null);
    try {
      setLoadingMsg("翻译修改指令...");
      const translatedPrompt = await fetchWithRetry(() => translateDescription(modifyPrompt));
      setLoadingMsg("AI 修改线稿中...");
      const img = await fetchWithRetry(() => editImage(
        `Modify this black and white line art based on the instruction: ${translatedPrompt}. Keep the same style: thick black lines on white background, 2D orthogonal front view, character on a circular base.`,
        workflowData.step1Image
      ));
      setWorkflowData(prev => ({ ...prev, step1Image: img }));
      setModifyPrompt("");
    } catch (e) { setError("修改失败: " + e.message); }
    finally { setLoading(false); }
  };

  // Step 2: 加固
  const handleStep2 = async (skip) => {
    if (skip) {
      setWorkflowData(prev => ({ ...prev, step2Image: prev.step1Image }));
      goToNextStep(2);
      return;
    }
    setLoading(true); setError(null); setLoadingMsg("Step 2: 结构加固中...");
    try {
      const img = await fetchWithRetry(() => refineStructure(workflowData.step1Image, sceneId));
      setWorkflowData(prev => ({ ...prev, step2Image: img }));
      goToNextStep(2);
    } catch (e) { setError("加固失败"); } finally { setLoading(false); }
  };

  // Step 3: 上色
  const handleStep3 = async () => {
    setLoading(true); setError(null); setLoadingMsg("Step 3: 填色中...");
    try {
      const img = await fetchWithRetry(() => colorFill(workflowData.step2Image, workflowData.colors, sceneId));
      setWorkflowData(prev => ({ ...prev, step3Image: img }));
      goToNextStep(3);
    } catch (e) { setError("上色失败"); } finally { setLoading(false); }
  };

  // Step 4: 导出浮雕
  const handleExportRelief = () => {
    if (!meshToExport.current) return;
    const result = exportToObj(meshToExport.current);
    if (!result) return;
    const blob = new Blob([result], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `relief_model_${Date.now()}.obj`;
    link.click();
    URL.revokeObjectURL(url);
  };

  const handleExport3mf = async () => {
    if (!meshToExport.current || !workflowData.step3Image) return;
    await exportTo3mf(meshToExport.current, workflowData.step3Image);
  };

  // Meshy AI 3D 生成
  const handleMeshy3D = async () => {
    const sourceImage = workflowData.step3Image || workflowData.step2Image || workflowData.step1Image;
    if (!sourceImage) return;
    // lowpoly/voxel 风格使用 Meshy lowpoly 模式
    const modelType = (workflowData.style === 'lowpoly' || workflowData.style === 'voxel') ? 'lowpoly' : 'standard';
    setLoading(true); setError(null);
    setLoadingMsg(`Meshy AI 3D 建模中${modelType === 'lowpoly' ? '（低面数模式）' : ''}（可能需要几分钟）...`);
    try {
      const result = await generateMeshy3D(sourceImage, modelType);
      setMeshy3dResult(result);
    } catch (e) { setError("3D 生成失败: " + e.message); }
    finally { setLoading(false); }
  };

  // 饼干模具导出
  const handleExportContour = async () => {
    const sourceImage = workflowData.step3Image || workflowData.step2Image || workflowData.step1Image;
    if (!sourceImage) return;
    await exportContourCutter(sourceImage, contourConfig);
  };

  const runPrintAnalysis = async () => {
    setAnalyzing(true);
    try {
      const advice = await analyzePrintingConfig(workflowData.description, workflowData.colors, workflowData.style);
      setPrintAdvice(advice);
    } catch (e) { setError("AI 分析失败"); } finally { setAnalyzing(false); }
  };

  const downloadImage = (base64, name) => {
    const link = document.createElement('a');
    link.href = base64;
    link.download = `${name}.png`;
    link.click();
  };

  return (
    <div className="min-h-screen bg-slate-50 p-4 md:p-8 font-sans text-slate-900">
      <div className="max-w-7xl mx-auto">
        {/* Header */}
        <div className="flex items-center gap-4 mb-8 bg-white p-6 rounded-[2.5rem] border border-slate-200 shadow-sm">
           <div className="bg-gradient-to-br from-indigo-600 to-blue-700 p-3 rounded-2xl shadow-lg"><Box className="text-white" size={32} /></div>
           <div>
             <h1 className="text-2xl font-black tracking-tight text-slate-800 uppercase italic">AI 灵感工坊</h1>
             <p className="text-xs font-bold text-slate-400 tracking-widest mt-1">MULTI-SCENE 3D PRINTING WORKFLOW</p>
           </div>
        </div>

        <div className="grid grid-cols-1 lg:grid-cols-12 gap-8">
          {/* 左侧操作区 */}
          <div className="lg:col-span-4 space-y-4">
            {error && <div className="p-3 bg-red-50 text-red-600 text-xs rounded-xl border border-red-100 flex items-center gap-2"><AlertCircle size={14}/>{error}</div>}

            {/* 场景选择 */}
            <div className="p-5 rounded-[2rem] bg-white border border-slate-200 shadow-sm">
              <div className="flex items-center gap-2 mb-3">
                <Layers size={16} className="text-indigo-600"/>
                <span className="text-sm font-bold text-slate-800">选择场景</span>
              </div>
              <div className="grid grid-cols-4 gap-2">
                {Object.values(SCENE_PRESETS).map(s => {
                  const Icon = s.icon;
                  return (
                    <button key={s.id} onClick={() => handleSceneChange(s.id)} className={`p-2 rounded-xl border flex flex-col items-center gap-1 transition-all text-center ${sceneId === s.id ? 'bg-indigo-600 text-white border-indigo-600 shadow-md' : 'bg-slate-50 text-slate-500 hover:bg-white hover:border-slate-300'}`}>
                      {Icon ? React.createElement(Icon, { size: 16 }) : <Box size={16}/>}
                      <span className="text-[9px] font-bold leading-tight">{s.label}</span>
                    </button>
                  );
                })}
              </div>
              <p className="text-[10px] text-slate-400 mt-2">{currentScene.description}</p>
            </div>

            <StepControl active={currentStep === 1} completed={currentStep > 1} title="Step 1: 基础线稿 (Structure)" icon={<BrainCircuit size={16}/>}>
              <div className="space-y-4">
                <div className="grid grid-cols-3 gap-2">
                  {Object.values(STYLE_PRESETS).map(s => (
                    <button key={s.id} onClick={() => setWorkflowData(prev => ({...prev, style: s.id}))} className={`p-2 rounded-lg border flex flex-col items-center gap-1 transition-all ${workflowData.style === s.id ? 'bg-blue-600 text-white border-blue-600' : 'bg-slate-50 text-slate-400 hover:bg-white'}`}>
                      {s.icon} <span className="text-[9px]">{s.label}</span>
                    </button>
                  ))}
                </div>
                <textarea className="w-full p-3 bg-slate-50 border rounded-xl text-xs h-20" value={workflowData.description} onChange={(e) => setWorkflowData({...workflowData, description: e.target.value})} placeholder="输入描述..." />
                <input type="file" ref={fileInputRef} onChange={handleImageUpload} className="hidden" accept="image/*" />

                {!workflowData.step1Image ? (
                  <div className="flex flex-col gap-2">
                    {workflowData.uploadedReference && (
                      <div className="relative h-24 rounded-xl overflow-hidden border">
                        <img src={workflowData.uploadedReference} className="w-full h-full object-cover opacity-60" alt="ref" />
                        <button onClick={() => setWorkflowData(prev => ({...prev, uploadedReference: null}))} className="absolute top-1 right-1 bg-white rounded-full p-1"><X size={12}/></button>
                      </div>
                    )}
                    <button onClick={handleStep1} disabled={loading} className="w-full py-3 bg-blue-600 text-white rounded-xl text-xs font-bold flex items-center justify-center gap-2 shadow-lg hover:bg-blue-700 disabled:opacity-50">
                      {loading ? <><Loader2 className="animate-spin" size={14}/> {loadingMsg}</> : <><Sparkles size={14}/> {workflowData.uploadedReference ? '视觉分析并重绘' : '生成标准线稿'}</>}
                    </button>
                    {!workflowData.uploadedReference && <button onClick={() => fileInputRef.current?.click()} className="w-full py-2 bg-white border text-slate-500 rounded-xl text-xs font-bold hover:bg-slate-50 flex items-center justify-center gap-2"><Upload size={14}/> 上传参考图</button>}
                  </div>
                ) : (
                  <div className="space-y-3">
                    <div className="flex gap-2">
                      <input type="text" value={modifyPrompt} onChange={e => setModifyPrompt(e.target.value)} placeholder="输入修改指令，如：把头盔去掉..." className="flex-1 p-2 bg-slate-50 border rounded-lg text-xs" onKeyDown={e => e.key === 'Enter' && !loading && handleModifyImage()} />
                      <button onClick={handleModifyImage} disabled={loading || !modifyPrompt.trim()} className="px-3 py-2 bg-amber-500 text-white rounded-lg text-xs font-bold disabled:opacity-50 flex items-center gap-1">
                        {loading ? <Loader2 className="animate-spin" size={12}/> : <Wand2 size={12}/>} 修改
                      </button>
                    </div>
                    <div className="flex gap-2">
                      <button onClick={() => { setWorkflowData(prev => ({...prev, step1Image: null})); }} className="flex-1 py-2 bg-slate-100 text-slate-500 rounded-xl text-xs font-bold">重置</button>
                      <button onClick={() => goToNextStep(1.5)} className="flex-1 py-2 bg-green-600 text-white rounded-xl text-xs font-bold">
                        下一步 {isStepEnabled(2) ? '(去加固)' : isStepEnabled(3) ? '(去填色)' : '(去3D)'}
                      </button>
                    </div>
                  </div>
                )}
              </div>
            </StepControl>

            {isStepEnabled(2) && (
              <StepControl active={currentStep === 2} completed={currentStep > 2} title="Step 2: 结构加固 (Refinement)" icon={<Settings2 size={16}/>}>
                <div className="flex gap-2">
                  <button onClick={() => handleStep2(false)} disabled={loading} className="flex-1 py-3 bg-slate-800 text-white rounded-xl text-xs font-bold">{loading ? "加固中..." : "AI 结构加固"}</button>
                  <button onClick={() => handleStep2(true)} disabled={loading} className="px-4 bg-slate-100 rounded-xl text-xs font-bold">跳过</button>
                </div>
              </StepControl>
            )}

            {isStepEnabled(3) && (
              <StepControl active={currentStep === 3} completed={currentStep > 3} title="Step 3: 填色 (Color Fill)" icon={<Palette size={16}/>}>
                <div className="space-y-3">
                   <div className="space-y-2">
                     {workflowData.colors.map((c, idx) => (
                       <div key={idx} className="flex items-center gap-2">
                         <input type="color" value={c} onChange={e => { const newColors = [...workflowData.colors]; newColors[idx] = e.target.value; setWorkflowData(prev => ({...prev, colors: newColors})); }} className="w-7 h-7 rounded cursor-pointer border-0 p-0" />
                         <input type="text" value={c} onChange={e => { const newColors = [...workflowData.colors]; newColors[idx] = e.target.value; setWorkflowData(prev => ({...prev, colors: newColors})); }} className="flex-1 p-1.5 bg-slate-50 border rounded-lg text-xs font-mono" />
                         {workflowData.colors.length > 2 && <button onClick={() => { const newColors = workflowData.colors.filter((_, i) => i !== idx); setWorkflowData(prev => ({...prev, colors: newColors})); }} className="text-slate-300 hover:text-red-400 text-xs"><X size={12}/></button>}
                       </div>
                     ))}
                     {workflowData.colors.length < 6 && (
                       <button onClick={() => setWorkflowData(prev => ({...prev, colors: [...prev.colors, '#888888']}))} className="w-full py-1.5 border border-dashed border-slate-200 rounded-lg text-[10px] text-slate-400 hover:text-slate-600 hover:border-slate-300">+ 添加颜色</button>
                     )}
                   </div>
                   <button onClick={handleStep3} disabled={loading} className="w-full py-3 bg-orange-500 text-white rounded-xl text-xs font-bold">{loading ? "渲染中..." : "执行填色"}</button>
                </div>
              </StepControl>
            )}

            {/* Step 4: 3D 生成 */}
            <div className={`p-5 rounded-[2rem] border transition-all ${currentStep === 4 ? 'bg-indigo-600 border-indigo-400 shadow-xl' : 'bg-white opacity-50'}`}>
              <div className="flex items-center gap-2 mb-3 text-white"><Mountain size={16}/><span className="text-sm font-bold">Step 4: 3D 生成</span></div>
              {currentStep === 4 && (
                <div className="space-y-4">
                  {/* Mode Switch — show available modes based on scene */}
                  <div className="flex gap-2">
                    {sceneId !== 'cookieCutter' && (
                      <button onClick={() => setStep4Mode('relief')} className={`flex-1 py-2 rounded-lg text-xs font-bold transition-all ${step4Mode === 'relief' ? 'bg-white text-indigo-600' : 'bg-indigo-500 text-indigo-200'}`}>
                        <span className="flex items-center justify-center gap-1"><Layers size={12}/> 本地浮雕</span>
                      </button>
                    )}
                    {(sceneId === 'figurine' || sceneId === 'relief' || sceneId === 'keychain') && (
                      <button onClick={() => setStep4Mode('meshy3d')} className={`flex-1 py-2 rounded-lg text-xs font-bold transition-all ${step4Mode === 'meshy3d' ? 'bg-white text-indigo-600' : 'bg-indigo-500 text-indigo-200'}`}>
                        <span className="flex items-center justify-center gap-1"><Cpu size={12}/> Meshy AI 3D</span>
                      </button>
                    )}
                    {sceneId === 'cookieCutter' && (
                      <button onClick={() => setStep4Mode('contour')} className={`flex-1 py-2 rounded-lg text-xs font-bold transition-all ${step4Mode === 'contour' ? 'bg-white text-indigo-600' : 'bg-indigo-500 text-indigo-200'}`}>
                        <span className="flex items-center justify-center gap-1">{React.createElement(Cookie || Hexagon, { size: 12 })} 轮廓挤出</span>
                      </button>
                    )}
                  </div>

                  {step4Mode === 'relief' ? (
                    <div className="space-y-3">
                      <Slider label="基础厚度 (Base)" value={workflowData.reliefBaseHeight} min={0.5} max={10} step={0.5} onChange={v=>setWorkflowData(p=>({...p, reliefBaseHeight:v}))} />
                      <Slider label="浮雕深度 (Depth)" value={workflowData.reliefDepth} min={1} max={20} onChange={v=>setWorkflowData(p=>({...p, reliefDepth:v}))} />
                      <Slider label="网格精度 (Res)" value={workflowData.reliefResolution} min={64} max={256} step={32} onChange={v=>setWorkflowData(p=>({...p, reliefResolution:v}))} />
                      {currentScene.reliefConfig?.inverted && (
                        <div className="text-[10px] text-indigo-200 bg-indigo-500/30 p-2 rounded-lg">
                          <Sun size={10} className="inline mr-1"/> 透光片模式：暗处厚，亮处薄（反转亮度）
                        </div>
                      )}
                      {currentScene.reliefConfig?.mirrored && (
                        <div className="text-[10px] text-indigo-200 bg-indigo-500/30 p-2 rounded-lg">
                          {React.createElement(Stamp || FileBox, { size: 10, className: "inline mr-1" })} 印章模式：输出已水平镜像
                        </div>
                      )}
                      {sceneId !== 'lithophane' && (
                        <button onClick={handleExport3mf} className="w-full py-3 bg-white text-indigo-600 rounded-xl text-xs font-black shadow-lg flex items-center justify-center gap-2">
                          <Download size={14}/> 导出 3MF（带颜色）
                        </button>
                      )}
                      <button onClick={handleExportRelief} className="w-full py-2 bg-indigo-500/50 text-indigo-100 rounded-xl text-[10px] font-bold flex items-center justify-center gap-2">
                        <Download size={12}/> 导出 OBJ（无颜色）
                      </button>
                    </div>
                  ) : step4Mode === 'contour' ? (
                    <div className="space-y-3">
                      <p className="text-indigo-200 text-[10px]">从轮廓图提取边缘并挤出薄壁，生成饼干模具 OBJ 文件。</p>
                      <Slider label="壁高 (mm)" value={contourConfig.wallHeight} min={5} max={30} onChange={v=>setContourConfig(p=>({...p, wallHeight:v}))} />
                      <Slider label="壁厚 (mm)" value={contourConfig.wallThickness} min={0.8} max={3} step={0.2} onChange={v=>setContourConfig(p=>({...p, wallThickness:v}))} />
                      <button onClick={handleExportContour} className="w-full py-3 bg-white text-indigo-600 rounded-xl text-xs font-black shadow-lg flex items-center justify-center gap-2">
                        <Download size={14}/> 导出饼干模具 OBJ
                      </button>
                    </div>
                  ) : (
                    <div className="space-y-3">
                      <p className="text-indigo-200 text-[10px]">使用 Meshy AI 从图片生成完整 3D 模型（含贴图），可能需要 2-5 分钟。</p>
                      <button onClick={handleMeshy3D} disabled={loading || meshy3dResult} className="w-full py-3 bg-white text-indigo-600 rounded-xl text-xs font-black shadow-lg flex items-center justify-center gap-2 disabled:opacity-50">
                        {loading ? <><Loader2 className="animate-spin" size={14}/> {loadingMsg}</> : meshy3dResult ? <><CheckCircle2 size={14}/> 已生成</> : <><Cpu size={14}/> 生成 AI 3D 模型</>}
                      </button>
                      {meshy3dResult && (
                        <div className="space-y-2">
                          <a href={meshy3dResult.model_urls?.glb} target="_blank" className="w-full py-2 bg-indigo-500 text-white rounded-lg text-xs font-bold flex items-center justify-center gap-1"><Download size={12}/> 下载 GLB</a>
                          <div className="flex gap-2">
                            {meshy3dResult.model_urls?.obj && <a href={meshy3dResult.model_urls.obj} target="_blank" className="flex-1 py-1.5 bg-indigo-500/50 text-indigo-100 rounded-lg text-[10px] font-bold text-center">OBJ</a>}
                            {meshy3dResult.model_urls?.fbx && <a href={meshy3dResult.model_urls.fbx} target="_blank" className="flex-1 py-1.5 bg-indigo-500/50 text-indigo-100 rounded-lg text-[10px] font-bold text-center">FBX</a>}
                            {meshy3dResult.model_urls?.usdz && <a href={meshy3dResult.model_urls.usdz} target="_blank" className="flex-1 py-1.5 bg-indigo-500/50 text-indigo-100 rounded-lg text-[10px] font-bold text-center">USDZ</a>}
                          </div>
                        </div>
                      )}
                    </div>
                  )}
                </div>
              )}
            </div>
          </div>

          {/* 右侧展示区 */}
          <div className="lg:col-span-8 space-y-6">
            {/* 3D 预览 */}
            <div className="bg-slate-900 rounded-[2.5rem] overflow-hidden shadow-2xl relative min-h-[500px] border border-slate-800 flex items-center justify-center group">
               {currentStep >= 4 && step4Mode === 'meshy3d' && meshy3dResult?.model_urls?.glb ? (
                 <div style={{position:'absolute',top:0,left:0,right:0,bottom:0}}>
                   <MeshyScene glbUrl={meshy3dResult.model_urls.glb} />
                   <div className="absolute bottom-6 left-6 text-slate-500 text-[10px] font-mono pointer-events-none">MESHY AI 3D MODEL</div>
                   <div className="absolute bottom-0 right-0 p-6">
                      <button onClick={runPrintAnalysis} disabled={analyzing} className="text-[10px] bg-indigo-600/80 hover:bg-indigo-600 text-white px-3 py-1.5 rounded-lg flex items-center gap-1 backdrop-blur">{analyzing ? <Loader2 className="animate-spin" size={10}/> : <Zap size={10}/>} 打印建议</button>
                      {printAdvice && <div className="mt-2 text-[10px] text-slate-300 bg-slate-800/80 p-3 rounded-xl max-w-xs whitespace-pre-wrap backdrop-blur">{printAdvice}</div>}
                   </div>
                 </div>
               ) : currentStep >= 4 && step4Mode === 'relief' && (workflowData.step3Image || workflowData.step2Image || workflowData.step1Image) ? (
                 <div style={{position:'absolute',top:0,left:0,right:0,bottom:0}}>
                   <ReliefScene
                     imageBase64={workflowData.step3Image || workflowData.step2Image || workflowData.step1Image}
                     depth={workflowData.reliefDepth}
                     baseHeight={workflowData.reliefBaseHeight}
                     smoothing={workflowData.reliefResolution}
                     inverted={!!currentScene.reliefConfig?.inverted}
                     mirrored={!!currentScene.reliefConfig?.mirrored}
                     cutout={!!currentScene.reliefConfig?.cutout}
                     onMeshUpdate={(mesh) => meshToExport.current = mesh}
                   />
                   <div className="absolute bottom-6 left-6 text-slate-500 text-[10px] font-mono pointer-events-none">LOCAL WEBGL RENDERER — {currentScene.label.toUpperCase()}</div>
                   <div className="absolute bottom-0 right-0 p-6">
                      <button onClick={runPrintAnalysis} disabled={analyzing} className="text-[10px] bg-indigo-600/80 hover:bg-indigo-600 text-white px-3 py-1.5 rounded-lg flex items-center gap-1 backdrop-blur">{analyzing ? <Loader2 className="animate-spin" size={10}/> : <Zap size={10}/>} 打印建议</button>
                      {printAdvice && <div className="mt-2 text-[10px] text-slate-300 bg-slate-800/80 p-3 rounded-xl max-w-xs whitespace-pre-wrap backdrop-blur">{printAdvice}</div>}
                   </div>
                 </div>
               ) : currentStep >= 4 && step4Mode === 'contour' && (workflowData.step1Image) ? (
                 <div className="w-full h-full flex items-center justify-center p-8 relative">
                   <img src={workflowData.step3Image || workflowData.step2Image || workflowData.step1Image} className="max-w-full max-h-full object-contain rounded-xl shadow-lg opacity-80" alt="contour preview" />
                   <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                     <div className="bg-slate-900/70 text-white px-6 py-3 rounded-2xl backdrop-blur text-sm font-bold">
                       {React.createElement(Cookie || Hexagon, { size: 16, className: "inline mr-2" })}
                       饼干模具 — 边缘将被挤出为薄壁
                     </div>
                   </div>
                   <div className="absolute bottom-6 left-6 text-slate-500 text-[10px] font-mono pointer-events-none">CONTOUR EXTRUSION MODE</div>
                 </div>
               ) : (() => {
                 const previewImg = workflowData.step3Image || workflowData.step2Image || workflowData.step1Image;
                 if (previewImg && !loading) {
                   return (
                     <div className="w-full h-full flex items-center justify-center p-8 relative">
                       <img src={previewImg} className="max-w-full max-h-full object-contain rounded-xl shadow-lg" alt="preview" />
                       <div className="absolute bottom-6 left-6 text-slate-500 text-[10px] font-mono pointer-events-none">
                         STEP {workflowData.step3Image ? 3 : workflowData.step2Image ? 2 : 1} PREVIEW
                       </div>
                     </div>
                   );
                 }
                 return (
                   <div className="text-slate-600 flex flex-col items-center">
                     {loading ? <Loader2 className="animate-spin text-blue-500 mb-4" size={48}/> : <ImageIcon size={64} className="opacity-20"/>}
                     <span className="text-xs font-bold tracking-widest uppercase mt-4">{loading ? loadingMsg : "等待完成前序步骤"}</span>
                   </div>
                 );
               })()}
            </div>

            <div className="grid grid-cols-3 gap-4">
              {[workflowData.step1Image, workflowData.step2Image, workflowData.step3Image].map((img, i) => (
                <div key={i} className="aspect-square bg-white rounded-2xl border border-slate-200 p-4 flex items-center justify-center relative shadow-sm group">
                  {img ? (
                    <>
                      <img src={img} className="max-w-full max-h-full object-contain" alt="step" />
                      <button onClick={() => downloadImage(img, `step_${i+1}`)} className="absolute top-2 right-2 p-1.5 bg-white rounded-lg shadow-sm opacity-0 group-hover:opacity-100 transition-opacity hover:text-blue-600"><Download size={12}/></button>
                    </>
                  ) : <span className="text-slate-300 text-[10px] font-bold">STEP {i+1}</span>}
                </div>
              ))}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

// Mount the app
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(React.createElement(AiWorkshop));
