import React, { useState, useEffect, useRef } from 'react';
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
import { 
  Box, Download, RefreshCcw, Info, 
  CheckCircle2, AlertCircle, Loader2, Image as ImageIcon, 
  Cpu, Wand2, RotateCcw, Sticker, Printer, Zap, Sparkles, 
  Grid3X3, Hexagon, Ghost, Bot, Upload, X, FileBox, ScanEye, 
  Settings2, Palette, BrainCircuit, Layers, Mountain
} from 'lucide-react';

// --- 全局配置 ---
const apiKey = ""; 

// ==========================================
// part 1: 公共工具函数
// ==========================================

const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));

async function fetchWithRetry(fn, maxRetries = 5) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (err) {
      if (i === maxRetries - 1) throw err;
      const delay = Math.pow(2, i) * 1000;
      await wait(delay);
    }
  }
}

// 纯 JS 实现的 OBJ 导出
function exportToObj(mesh) {
  if (!mesh || !mesh.geometry) return;
  const geometry = mesh.geometry;
  const positions = geometry.attributes.position.array;
  const indices = geometry.index ? geometry.index.array : null;
  let output = '# Procedural Relief Model\n# Generated by Unified 3D Workbench\no Mesh\n';
  for (let i = 0; i < positions.length; i += 3) {
    output += `v ${positions[i]} ${positions[i+1]} ${positions[i+2]}\n`;
  }
  if (indices) {
    for (let i = 0; i < indices.length; i += 3) {
      output += `f ${indices[i]+1} ${indices[i+1]+1} ${indices[i+2]+1}\n`;
    }
  } else {
    const vertexCount = positions.length / 3;
    for (let i = 0; i < vertexCount; i += 3) {
      output += `f ${i+1} ${i+2} ${i+3}\n`;
    }
  }
  return output;
}

// ==========================================
// Part 2: AI 引擎服务 (严格对齐产品文档)
// ==========================================

const STYLE_PRESETS = {
  standard: { id: 'standard', label: '标准 FDM', icon: <Box size={14} />, promptModifier: 'designed as a children\'s toy model' },
  lowpoly: { id: 'lowpoly', label: '低多边形', icon: <Hexagon size={14} />, promptModifier: 'low poly style, faceted geometry' },
  voxel: { id: 'voxel', label: '体素风', icon: <Grid3X3 size={14} />, promptModifier: 'voxel art style, constructed from cubes' },
  chibi: { id: 'chibi', label: 'Q版可爱', icon: <Ghost size={14} />, promptModifier: 'chibi style, super deformed proportions' },
  mecha: { id: 'mecha', label: '机甲硬核', icon: <Bot size={14} />, promptModifier: 'mecha style, industrial robotic parts' },
  organic: { id: 'organic', label: '生物有机', icon: <Sparkles size={14} />, promptModifier: 'organic style, smooth biomimetic shapes' }
};

async function describeImage(base64Image) {
  const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
  const base64Data = base64Image.split(',')[1];
  const payload = {
    contents: [{ parts: [{ text: "Describe the main subject of this image clearly for a 3D modeler. Focus on the character/object only. Ignore background." }, { inlineData: { mimeType: "image/png", data: base64Data } }] }]
  };
  const response = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
  if (!response.ok) throw new Error('VLM Analysis failed');
  const result = await response.json();
  return result.candidates?.[0]?.content?.parts?.[0]?.text;
}

// 仅用于翻译用户输入，不做过多发散，保持忠实
async function translateDescription(userInput) {
  const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
  const systemPrompt = `Translate the user's description into concise English suitable for a prompt. Do not add extra artistic details.`;
  const response = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: [{ role: "user", parts: [{ text: userInput }] }], systemInstruction: { parts: [{ text: systemPrompt }] } }) });
  if (!response.ok) throw new Error('Translation failed');
  const result = await response.json();
  return result.candidates?.[0]?.content?.parts?.[0]?.text || userInput;
}

// Step 1: 构建基础线稿 (Strict adherence to Doc)
async function generateImage(prompt, styleId) {
  const url = `https://generativelanguage.googleapis.com/v1beta/models/imagen-4.0-generate-001:predict?key=${apiKey}`;
  const styleConfig = STYLE_PRESETS[styleId];
  
  // 严格遵循文档 Step 1 格式
  const finalPrompt = `
    A black and white line art, 2D orthogonal front view, ${styleConfig.promptModifier}.
    Reference Character: ${prompt}.
    Core Requirements: ONLY thick black lines on white background. Lines must be clear, closed, no breaks.
    Structure Requirements: Character MUST be connected to a thick circular base at the bottom. Compact structure, avoid thin or floating parts, suitable for 3D FDM printing. Emphasize outlines and separation lines.
    Negative Prompt: multiple views, character sheet, split screen, side view, back view, gray scale, shading, gradient, text, watermark, thin lines, broken lines.
  `;
  
  const response = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ instances: { prompt: finalPrompt }, parameters: { sampleCount: 1 } }) });
  if (!response.ok) throw new Error('Imagen failed');
  const result = await response.json();
  return `data:image/png;base64,${result.predictions[0].bytesBase64Encoded}`;
}

// 通用编辑函数
async function editImage(prompt, base64Image) {
  const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent?key=${apiKey}`;
  const base64Data = base64Image.split(',')[1];
  const payload = { contents: [{ parts: [{ text: prompt }, { inlineData: { mimeType: "image/png", data: base64Data } }] }], generationConfig: { responseModalities: ['TEXT', 'IMAGE'] } };
  const response = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
  if (!response.ok) throw new Error('Edit failed');
  const result = await response.json();
  const base64 = result.candidates?.[0]?.content?.parts?.find(p => p.inlineData)?.inlineData?.data;
  if (!base64) throw new Error('No image returned');
  return `data:image/png;base64,${base64}`;
}

// Step 1 (Reference Mode): 参考图转线稿 (Strict)
async function traceImage(referenceDesc, base64Image, styleId) {
    const styleConfig = STYLE_PRESETS[styleId];
    // 使用 Gemini 2.5 进行图生图，严格重绘为线稿
    const prompt = `
    Trace this reference image into a black and white line art, 2D orthogonal front view.
    Target Style: ${styleConfig.promptModifier}.
    Subject: ${referenceDesc}.
    Core Requirements: Convert all colors to thick black outlines on white background. Remove all shading and gradients.
    Structure: Ensure the character stands on a thick circular base. Check for closed loops.
    CRITICAL: Output a SINGLE VIEW only. Do not generate a character sheet.
    `;
    return await editImage(prompt, base64Image);
}

// Step 2: 结构优化 (Strict adherence to Doc)
async function refineStructure(base64Image) {
    const prompt = `
    Optimize the structure of the previous line art.
    Core Requirements: Significantly thicken all weak connection points (neck, ankles, arm connections). Ensure the base connection is very solid. Check and close all tiny line gaps. Maintain black and white line art style.
    `;
    return await editImage(prompt, base64Image);
}

// Step 3: 四色填充 (Strict adherence to Doc)
async function colorFill(base64Image, customColors) {
    // 默认文档要求颜色，但也支持用户微调
    const colors = customColors && customColors.length > 0 ? customColors.join(', ') : "Black, Orange, White, Green";
    
    const prompt = `
    Vector color fill of the previous line art.
    Strict Color Limit: 4 colors only (${colors}).
    Coloring Rules:
    1. Keep original thick black outlines unchanged.
    2. Fill closed areas with the specified colors.
    3. Style: Flat Design, pure solid color blocks. NO gradients, NO shadows, NO highlights, NO textures. Clear boundaries.
    4. Fill the base with Black or Dark Green for stability appearance.
    `;
    return await editImage(prompt, base64Image);
}

async function analyzePrintingConfig(description, colors, styleId) {
  const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
  const prompt = `3D Printing Expert Advice for FDM Slicing based on this model description:
  Model: ${description} (Style: ${styleId})
  Colors: ${colors.join(', ')}
  Provide: 1. Layer Height/Wall Thickness 2. Support Strategy (Overhangs) 3. Infill/Orientation 4. Post-processing. Markdown format.`;
  const response = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] }) });
  if (!response.ok) throw new Error('Analysis failed');
  const result = await response.json();
  return result.candidates?.[0]?.content?.parts?.[0]?.text;
}

// ==========================================
// Part 3: 原生 Three.js 浮雕生成引擎 (Relief Engine)
// ==========================================

function ReliefScene({ imageBase64, depth = 5, smoothing = 128, onMeshUpdate }) {
  const containerRef = useRef(null);
  const sceneRef = useRef(null);
  const meshRef = useRef(null);

  useEffect(() => {
    if (!containerRef.current) return;
    const w = containerRef.current.clientWidth;
    const h = containerRef.current.clientHeight;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1e293b);

    const camera = new THREE.PerspectiveCamera(45, w/h, 0.1, 1000);
    camera.position.set(0, -50, 100); 

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(w, h);
    renderer.shadowMap.enabled = true;
    containerRef.current.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(50, 50, 100);
    dirLight.castShadow = true;
    scene.add(dirLight);

    const grid = new THREE.GridHelper(200, 20, 0x444444, 0x222222);
    grid.rotation.x = Math.PI / 2;
    scene.add(grid);

    sceneRef.current = scene;

    let frameId;
    const animate = () => {
      frameId = requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    };
    animate();

    const handleResize = () => {
      if(!containerRef.current) return;
      camera.aspect = containerRef.current.clientWidth / containerRef.current.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(containerRef.current.clientWidth, containerRef.current.clientHeight);
    };
    window.addEventListener('resize', handleResize);

    return () => {
      cancelAnimationFrame(frameId);
      window.removeEventListener('resize', handleResize);
      if (containerRef.current) containerRef.current.removeChild(renderer.domElement);
      renderer.dispose();
    };
  }, []);

  useEffect(() => {
    if (!imageBase64 || !sceneRef.current) return;

    const img = new Image();
    img.src = imageBase64;
    img.onload = () => {
      const canvas = document.createElement('canvas');
      const res = Math.min(smoothing, 256); 
      canvas.width = res;
      canvas.height = res;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, res, res);
      const imgData = ctx.getImageData(0, 0, res, res);
      const data = imgData.data;

      const geometry = new THREE.PlaneGeometry(60, 60, res - 1, res - 1);
      const posAttribute = geometry.attributes.position;

      for (let i = 0; i < posAttribute.count; i++) {
        const pixelIndex = i * 4; 
        if (pixelIndex < data.length) {
          const r = data[pixelIndex];
          const g = data[pixelIndex + 1];
          const b = data[pixelIndex + 2];
          const brightness = (r * 0.299 + g * 0.587 + b * 0.114) / 255;
          const z = brightness * depth;
          posAttribute.setZ(i, z);
        }
      }

      geometry.computeVertexNormals();

      const texture = new THREE.Texture(img);
      texture.needsUpdate = true;
      const material = new THREE.MeshStandardMaterial({ 
        map: texture, 
        side: THREE.DoubleSide,
        roughness: 0.4,
        metalness: 0.2,
        displacementScale: depth
      });

      if (meshRef.current) {
        sceneRef.current.remove(meshRef.current);
        meshRef.current.geometry.dispose();
        meshRef.current.material.dispose();
      }

      const mesh = new THREE.Mesh(geometry, material);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      mesh.position.z = 0.5;

      sceneRef.current.add(mesh);
      meshRef.current = mesh;

      if (onMeshUpdate) onMeshUpdate(mesh);
    };
  }, [imageBase64, depth, smoothing]);

  return <div ref={containerRef} className="w-full h-full" />;
}

// ==========================================
// Part 4: UI 组件
// ==========================================

function StepControl({ active, completed, title, icon, children }) {
  return (
    <div className={`p-5 rounded-[2rem] border transition-all duration-300 ${active ? 'bg-white border-blue-200 shadow-xl scale-[1.01]' : 'bg-white/60 border-slate-100 opacity-80'}`}>
      <div className="flex items-center gap-3 mb-4">
        <div className={`flex items-center justify-center w-8 h-8 rounded-full font-bold text-sm ${active ? 'bg-blue-600 text-white' : 'bg-slate-200 text-slate-500'}`}>
          {completed ? <CheckCircle2 size={16}/> : (active ? <Zap size={16}/> : <Box size={16}/>)}
        </div>
        <div className="flex-1 font-bold text-slate-800 text-sm">{title}</div>
      </div>
      {active && <div className="animate-in fade-in slide-in-from-top-2">{children}</div>}
    </div>
  );
}

function Slider({ label, value, min, max, step=1, onChange }) {
  return (
    <div className="space-y-1">
      <div className="flex justify-between text-[10px] text-slate-400"><span>{label}</span><span className="font-mono text-blue-400">{value}</span></div>
      <input type="range" min={min} max={max} step={step} value={value} onChange={e=>onChange(parseFloat(e.target.value))} className="w-full h-1 bg-slate-800 rounded-lg appearance-none cursor-pointer accent-indigo-500" />
    </div>
  );
}

// ==========================================
// Part 5: 主程序
// ==========================================

export default function AiWorkshop() {
  const [currentStep, setCurrentStep] = useState(1);
  const [loading, setLoading] = useState(false);
  const [loadingMsg, setLoadingMsg] = useState("");
  const [error, setError] = useState(null);
  const [analyzing, setAnalyzing] = useState(false);
  const [printAdvice, setPrintAdvice] = useState(null);
  const [workflowData, setWorkflowData] = useState({
    description: "一只戴着宇航头盔的小猫，正坐姿态",
    style: 'standard', modifyPrompt: "", uploadedReference: null,
    step1Image: null, step2Image: null, step3Image: null, 
    colors: ['Black', 'Orange', 'White', 'Green'], // 默认符合文档要求
    reliefDepth: 5, reliefResolution: 128
  });
  const fileInputRef = useRef(null);
  const meshToExport = useRef(null);

  const handleImageUpload = (e) => {
    const file = e.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (ev) => setWorkflowData(prev => ({ ...prev, uploadedReference: ev.target.result, step1Image: null }));
      reader.readAsDataURL(file);
    }
  };

  // Step 1: 线稿 (Strict)
  const handleStep1 = async () => {
    setLoading(true); setError(null);
    try {
      let subjectDesc = workflowData.description;
      if (workflowData.uploadedReference) {
        // VLM + Trace
        setLoadingMsg("VLM 视觉分析...");
        subjectDesc = await fetchWithRetry(() => describeImage(workflowData.uploadedReference));
        setWorkflowData(prev => ({ ...prev, description: subjectDesc }));
        
        setLoadingMsg("参考图重绘 (标准线稿)...");
        const img = await fetchWithRetry(() => traceImage(subjectDesc, workflowData.uploadedReference, workflowData.style));
        setWorkflowData(prev => ({ ...prev, step1Image: img }));
      } else {
        // Text + Imagen
        setLoadingMsg("翻译提示词...");
        const translatedPrompt = await fetchWithRetry(() => translateDescription(subjectDesc));
        setLoadingMsg("生成标准线稿...");
        const img = await fetchWithRetry(() => generateImage(translatedPrompt, workflowData.style));
        setWorkflowData(prev => ({ ...prev, step1Image: img }));
      }
    } catch (e) { setError("生成失败: " + e.message); } 
    finally { setLoading(false); }
  };

  // Step 2: 加固 (Strict)
  const handleStep2 = async (skip) => {
    if (skip) { setWorkflowData(prev => ({ ...prev, step2Image: prev.step1Image })); setCurrentStep(3); return; }
    setLoading(true); setError(null); setLoadingMsg("Step 2: 结构加固中...");
    try {
      const img = await fetchWithRetry(() => refineStructure(workflowData.step1Image));
      setWorkflowData(prev => ({ ...prev, step2Image: img })); setCurrentStep(3);
    } catch (e) { setError("加固失败"); } finally { setLoading(false); }
  };

  // Step 3: 上色 (Strict)
  const handleStep3 = async () => {
    setLoading(true); setError(null); setLoadingMsg("Step 3: 四色填充中...");
    try {
      const img = await fetchWithRetry(() => colorFill(workflowData.step2Image, workflowData.colors));
      setWorkflowData(prev => ({ ...prev, step3Image: img })); setCurrentStep(4);
    } catch (e) { setError("上色失败"); } finally { setLoading(false); }
  };

  // Step 4: 导出浮雕
  const handleExportRelief = () => {
    if (!meshToExport.current) return;
    const result = exportToObj(meshToExport.current);
    if (!result) return;
    const blob = new Blob([result], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `relief_model_${Date.now()}.obj`;
    link.click();
    URL.revokeObjectURL(url);
  };

  const runPrintAnalysis = async () => {
    setAnalyzing(true);
    try {
      const advice = await analyzePrintingConfig(workflowData.description, workflowData.colors, workflowData.style);
      setPrintAdvice(advice);
    } catch (e) { setError("AI 分析失败"); } finally { setAnalyzing(false); }
  };

  const downloadImage = (base64, name) => {
    const link = document.createElement('a');
    link.href = base64;
    link.download = `${name}.png`;
    link.click();
  };

  return (
    <div className="min-h-screen bg-slate-50 p-4 md:p-8 font-sans text-slate-900">
      <div className="max-w-7xl mx-auto">
        {/* Header */}
        <div className="flex items-center gap-4 mb-8 bg-white p-6 rounded-[2.5rem] border border-slate-200 shadow-sm">
           <div className="bg-gradient-to-br from-indigo-600 to-blue-700 p-3 rounded-2xl shadow-lg"><Box className="text-white" size={32} /></div>
           <div>
             <h1 className="text-2xl font-black tracking-tight text-slate-800 uppercase italic">AI 灵感工坊</h1>
             <p className="text-xs font-bold text-slate-400 tracking-widest mt-1">STRICT 3-STEP 3D PRINTING WORKFLOW</p>
           </div>
        </div>

        <div className="grid grid-cols-1 lg:grid-cols-12 gap-8">
          {/* 左侧操作区 */}
          <div className="lg:col-span-4 space-y-4">
            {error && <div className="p-3 bg-red-50 text-red-600 text-xs rounded-xl border border-red-100 flex items-center gap-2"><AlertCircle size={14}/>{error}</div>}
            
            <StepControl active={currentStep === 1} completed={currentStep > 1} title="Step 1: 基础线稿 (Structure)" icon={<BrainCircuit size={16}/>}>
              <div className="space-y-4">
                <div className="grid grid-cols-3 gap-2">
                  {Object.values(STYLE_PRESETS).map(s => (
                    <button key={s.id} onClick={() => setWorkflowData(prev => ({...prev, style: s.id}))} className={`p-2 rounded-lg border flex flex-col items-center gap-1 transition-all ${workflowData.style === s.id ? 'bg-blue-600 text-white border-blue-600' : 'bg-slate-50 text-slate-400 hover:bg-white'}`}>
                      {s.icon} <span className="text-[9px]">{s.label}</span>
                    </button>
                  ))}
                </div>
                <textarea className="w-full p-3 bg-slate-50 border rounded-xl text-xs h-20" value={workflowData.description} onChange={(e) => setWorkflowData({...workflowData, description: e.target.value})} placeholder="输入描述..." />
                <input type="file" ref={fileInputRef} onChange={handleImageUpload} className="hidden" accept="image/*" />
                
                {!workflowData.step1Image ? (
                  <div className="flex flex-col gap-2">
                    {workflowData.uploadedReference && (
                      <div className="relative h-24 rounded-xl overflow-hidden border">
                        <img src={workflowData.uploadedReference} className="w-full h-full object-cover opacity-60" alt="ref" />
                        <button onClick={() => setWorkflowData(prev => ({...prev, uploadedReference: null}))} className="absolute top-1 right-1 bg-white rounded-full p-1"><X size={12}/></button>
                      </div>
                    )}
                    <button onClick={handleStep1} disabled={loading} className="w-full py-3 bg-blue-600 text-white rounded-xl text-xs font-bold flex items-center justify-center gap-2 shadow-lg hover:bg-blue-700 disabled:opacity-50">
                      {loading ? <><Loader2 className="animate-spin" size={14}/> {loadingMsg}</> : <><Sparkles size={14}/> {workflowData.uploadedReference ? '视觉分析并重绘' : '生成标准线稿'}</>}
                    </button>
                    {!workflowData.uploadedReference && <button onClick={() => fileInputRef.current?.click()} className="w-full py-2 bg-white border text-slate-500 rounded-xl text-xs font-bold hover:bg-slate-50 flex items-center justify-center gap-2"><Upload size={14}/> 上传参考图</button>}
                  </div>
                ) : (
                  <div className="space-y-2">
                    <div className="flex gap-2">
                      <button onClick={() => { setWorkflowData(prev => ({...prev, step1Image: null})); }} className="flex-1 py-2 bg-slate-100 text-slate-500 rounded-xl text-xs font-bold">重置</button>
                      <button onClick={() => setCurrentStep(2)} className="flex-1 py-2 bg-green-600 text-white rounded-xl text-xs font-bold">下一步 (去加固)</button>
                    </div>
                  </div>
                )}
              </div>
            </StepControl>

            <StepControl active={currentStep === 2} completed={currentStep > 2} title="Step 2: 结构加固 (Refinement)" icon={<Settings2 size={16}/>}>
              <div className="flex gap-2">
                <button onClick={() => handleStep2(false)} disabled={loading} className="flex-1 py-3 bg-slate-800 text-white rounded-xl text-xs font-bold">{loading ? "加固中..." : "AI 结构加固"}</button>
                <button onClick={() => handleStep2(true)} disabled={loading} className="px-4 bg-slate-100 rounded-xl text-xs font-bold">跳过</button>
              </div>
            </StepControl>

            <StepControl active={currentStep === 3} completed={currentStep > 3} title="Step 3: 四色填充 (Color Fill)" icon={<Palette size={16}/>}>
              <div className="space-y-3">
                 <div className="flex flex-wrap gap-1">
                   {workflowData.colors.map(c => <span key={c} className="text-[10px] px-2 py-1 bg-slate-100 rounded-lg text-slate-500">{c}</span>)}
                 </div>
                 <button onClick={handleStep3} disabled={loading} className="w-full py-3 bg-orange-500 text-white rounded-xl text-xs font-bold">{loading ? "渲染中..." : "执行四色填充"}</button>
              </div>
            </StepControl>

            {/* Step 4: 本地浮雕参数 */}
            <div className={`p-5 rounded-[2rem] border transition-all ${currentStep === 4 ? 'bg-indigo-600 border-indigo-400 shadow-xl' : 'bg-white opacity-50'}`}>
              <div className="flex items-center gap-2 mb-3 text-white"><Mountain size={16}/><span className="text-sm font-bold">Step 4: 浮雕生成 (Local)</span></div>
              {currentStep === 4 && (
                <div className="space-y-4">
                  <div className="space-y-2">
                     <Slider label="浮雕深度 (Depth)" value={workflowData.reliefDepth} min={1} max={20} onChange={v=>setWorkflowData(p=>({...p, reliefDepth:v}))} />
                     <Slider label="网格精度 (Res)" value={workflowData.reliefResolution} min={64} max={256} step={32} onChange={v=>setWorkflowData(p=>({...p, reliefResolution:v}))} />
                  </div>
                  <button onClick={handleExportRelief} className="w-full py-3 bg-white text-indigo-600 rounded-xl text-xs font-black shadow-lg flex items-center justify-center gap-2">
                    <Download size={14}/> 导出浮雕 OBJ
                  </button>
                </div>
              )}
            </div>
          </div>

          {/* 右侧展示区 */}
          <div className="lg:col-span-8 space-y-6">
            {/* 3D 浮雕预览 */}
            <div className="bg-slate-900 rounded-[2.5rem] overflow-hidden shadow-2xl relative min-h-[500px] border border-slate-800 flex items-center justify-center group">
               {workflowData.step3Image && currentStep >= 4 ? (
                 <div className="w-full h-full relative">
                   <ReliefScene 
                     imageBase64={workflowData.step3Image} 
                     depth={workflowData.reliefDepth}
                     smoothing={workflowData.reliefResolution}
                     onMeshUpdate={(mesh) => meshToExport.current = mesh}
                   />
                   <div className="absolute bottom-6 left-6 text-slate-500 text-[10px] font-mono pointer-events-none">LOCAL WEBGL RENDERER (NO API)</div>
                   <div className="absolute bottom-0 right-0 p-6">
                      <button onClick={runPrintAnalysis} disabled={analyzing} className="text-[10px] bg-indigo-600/80 hover:bg-indigo-600 text-white px-3 py-1.5 rounded-lg flex items-center gap-1 backdrop-blur">{analyzing ? <Loader2 className="animate-spin" size={10}/> : <Zap size={10}/>} 打印建议</button>
                      {printAdvice && <div className="mt-2 text-[10px] text-slate-300 bg-slate-800/80 p-3 rounded-xl max-w-xs whitespace-pre-wrap backdrop-blur">{printAdvice}</div>}
                   </div>
                 </div>
               ) : (
                 <div className="text-slate-600 flex flex-col items-center">
                   {loading ? <Loader2 className="animate-spin text-blue-500 mb-4" size={48}/> : <ImageIcon size={64} className="opacity-20"/>}
                   <span className="text-xs font-bold tracking-widest uppercase mt-4">{loading ? loadingMsg : "等待完成前序步骤"}</span>
                 </div>
               )}
            </div>

            <div className="grid grid-cols-3 gap-4">
              {[workflowData.step1Image, workflowData.step2Image, workflowData.step3Image].map((img, i) => (
                <div key={i} className="aspect-square bg-white rounded-2xl border border-slate-200 p-4 flex items-center justify-center relative shadow-sm group">
                  {img ? (
                    <>
                      <img src={img} className="max-w-full max-h-full object-contain" alt="step" />
                      <button onClick={() => downloadImage(img, `step_${i+1}`)} className="absolute top-2 right-2 p-1.5 bg-white rounded-lg shadow-sm opacity-0 group-hover:opacity-100 transition-opacity hover:text-blue-600"><Download size={12}/></button>
                    </>
                  ) : <span className="text-slate-300 text-[10px] font-bold">STEP {i+1}</span>}
                </div>
              ))}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
